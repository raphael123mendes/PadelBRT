<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Padel Doubles Scheduler & Scoring (5 players)</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--accent:#22c1c3;--muted:#9aa6b2;color-scheme:dark}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071025,#0b1220);color:#e6eef6}
  .wrap{max-width:980px;margin:32px auto;padding:20px}
  header{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);margin-top:16px}
  input.player{width:calc(20% - 8px);min-width:120px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;cursor:pointer;color:#041018;font-weight:600}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
  .games{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
  @media(min-width:880px){.games{grid-template-columns:repeat(2,1fr)}}
  .game{padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;border:1px solid rgba(255,255,255,0.02)}
  .game h3{margin:0;font-size:14px}
  .pair{display:flex;gap:12px;align-items:center}
  .team{flex:1;padding:8px;border-radius:8px;background:rgba(0,0,0,0.2);display:flex;justify-content:space-between;align-items:center}
  .score-controls{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  .leader{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:12px}
  .leader .p{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-width:120px}
  .actions{display:flex;gap:8px;align-items:center;margin-left:auto}
  .muted{color:var(--muted)}
  .export{margin-left:8px}
  footer{margin-top:18px;font-size:12px;color:var(--muted)}
  .danger{background:linear-gradient(90deg,#ff6b6b,#ff8a8a);color:#071018}
  .ok{background:linear-gradient(90deg,#7bffb0,#3dbf8b);color:#061914}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Padel Scheduler & Scoring — 5 players, doubles</h1>
        <div class="small muted">Rotation rule: bench rotates each game — each player sits out for only one game. 15 games total. First to 3 games wins a match.</div>
      </div>
      <div style="margin-left:auto" class="actions">
        <button id="regen">Regenerate schedule</button>
        <button id="reset" class="secondary">Reset scores</button>
        <button id="export" class="secondary">Export JSON</button>
        <button id="importBtn" class="secondary">Import JSON</button>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <label class="small muted">Player names:</label>
        <input class="player" id="p0" placeholder="Player 1" value="Alice">
        <input class="player" id="p1" placeholder="Player 2" value="Bob">
        <input class="player" id="p2" placeholder="Player 3" value="Carlos">
        <input class="player" id="p3" placeholder="Player 4" value="Diego">
        <input class="player" id="p4" placeholder="Player 5" value="Emma">
        <div style="margin-left:8px">
          <label class="small muted">Start bench:</label>
          <select id="startBench"></select>
        </div>
        <button id="generate" class="secondary">Generate schedule</button>
      </div>

      <div style="margin-top:12px" class="small muted">Tip: the generator tries random starting benches if needed to find a valid schedule without repeated doubles straight.</div>
    </div>

    <div id="scheduleArea"></div>

    <div class="card" id="leaderboardCard" style="display:none">
      <h3>Leaderboard (cumulative match games won)</h3>
      <div id="leaderboard" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
    </div>

    <footer>Built for quick use. Export JSON to keep centralized copy. Host this file on GitHub Pages or Netlify to make it accessible online.</footer>
  </div>

<script>
/* Padel 5-player scheduler + scoring
   - bench rotation: bench = (startBench + gameIndex) % 5  (bench rotates every game; player sits out only one game)
   - for the 4 playing players, there are 3 possible pairings (partitions into two pairs)
   - choose pairings across 15 games to cover distinct matchups (each unique matchup used once)
   - forbid any double (pair) from playing in two consecutive games (strict check)
   - backtracking search to pick pairing per game
*/
(function(){
  // DOM refs
  const pEls = [byId('p0'),byId('p1'),byId('p2'),byId('p3'),byId('p4')];
  const startBenchSelect = byId('startBench');
  const generateBtn = byId('generate');
  const regenBtn = byId('regen');
  const resetBtn = byId('reset');
  const exportBtn = byId('export');
  const importBtn = byId('importBtn');
  const scheduleArea = byId('scheduleArea');
  const leaderboardCard = byId('leaderboardCard');
  const leaderboardDiv = byId('leaderboard');

  // init start bench select
  function refreshStartOptions(){
    const names = getNames();
    startBenchSelect.innerHTML = '';
    for(let i=0;i<5;i++){
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${names[i] || ('Player ' + (i+1))} (bench first)`;
      startBenchSelect.appendChild(opt);
    }
  }

  // helpers
  function byId(id){return document.getElementById(id)}
  function getNames(){return pEls.map(e=>e.value.trim()||e.placeholder)}
  function allPairsOf4(players){ // players: array of 4 indices -> returns array of [ [a,b],[c,d] ] pairings (unordered)
    const [a,b,c,d] = players;
    return [
      [[a,b],[c,d]],
      [[a,c],[b,d]],
      [[a,d],[b,c]]
    ];
  }
  function pairKey(pair){ // pair = [i,j]
    const [x,y]=pair.slice().sort((a,b)=>a-b);
    return `${x}-${y}`;
  }
  function matchupKey(pairA,pairB){ // unordered pairs of pairs, canonical key
    const k1 = pairKey(pairA), k2 = pairKey(pairB);
    return k1 < k2 ? `${k1}|${k2}` : `${k2}|${k1}`;
  }

  // Build options (3) for the 4 players that are playing when bench is benchIndex
  function allMatchupsForBench(benchIndex){
    const players = [0,1,2,3,4].filter(i=>i!==benchIndex);
    return allPairsOf4(players).map(p => ({pairs:p, key: matchupKey(p[0],p[1])}));
  }

  // Full search: For 15 games (g=0..14), bench = (startBench + g) % 5
  // for each game choose one of 3 pairings that has not yet been used (by matchupKey)
  // and doesn't create consecutive same double from previous game (strict)
  function findSchedule(startBench){
    const totalGames = 15;
    const usedMatchups = new Set();
    const schedule = new Array(totalGames);

    // Precompute options per game
    const options = [];
    for(let g=0;g<totalGames;g++){
      const bench = (startBench + g) % 5;
      const opts = allMatchupsForBench(bench).map(o => ({...o, bench}));
      options.push(opts);
    }

    // backtracking
    function backtrack(g, lastDoubleSet){
      if(g===totalGames) return true;
      // shuffle to increase chance of finding solution quickly
      const opts = shuffleArray(options[g].slice());
      for(const opt of opts){
        if(usedMatchups.has(opt.key)) continue;
        // build pair keys for this candidate
        const doubleKeyA = pairKey(opt.pairs[0]);
        const doubleKeyB = pairKey(opt.pairs[1]);
        // Strict check: none of these doubles should have played in previous game
        if(lastDoubleSet && (lastDoubleSet.has(doubleKeyA) || lastDoubleSet.has(doubleKeyB))) continue;

        // choose
        schedule[g] = {bench: opt.bench, pairs: opt.pairs.map(p=>p.slice()), key: opt.key, scores:[0,0], finished:false};
        usedMatchups.add(opt.key);
        const newLast = new Set([doubleKeyA,doubleKeyB]);

        if(backtrack(g+1, newLast)) return true;

        // undo
        usedMatchups.delete(opt.key);
        schedule[g] = null;
      }
      return false;
    }

    // attempt backtrack; return schedule or null
    const ok = backtrack(0, null);
    if(ok) return schedule;
    return null;
  }

  // Utility: Fisher-Yates shuffle
  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  // UI / scoring logic
  let currentState = null; // {names, startBench, schedule: [{bench,pairs,scores,finished}], playersStats:{gamesWon, matchesPlayed}}
  function buildNewState(startBench){
    const names = getNames();
    let schedule = null;
    // try more attempts with different start benches if needed
    let attempts = 0;
    let sb = startBench;
    while(attempts < 50){
      schedule = findSchedule(sb);
      if(schedule) break;
      sb = Math.floor(Math.random()*5);
      attempts++;
    }
    if(!schedule) {
      alert('Failed to generate a valid schedule (rare). Try regenerating.');
      return null;
    }
    // convert schedule items to include player name strings and other fields
    for(let i=0;i<schedule.length;i++){
      schedule[i].index = i;
      schedule[i].scores = [0,0]; // games within match
      schedule[i].finished = false;
    }
    const state = {
      names,
      startBench: sb,
      schedule,
      players: Array.from({length:5}, ()=>({gamesWon:0, matchesPlayed:0}))
    };
    return state;
  }

  function renderSchedule(){
    scheduleArea.innerHTML = '';
    if(!currentState) return;
    const names = currentState.names;
    const frag = document.createDocumentFragment();

    // header card for bench info
    const benchCard = document.createElement('div');
    benchCard.className = 'card';
    benchCard.innerHTML = `<div style="display:flex;align-items:center;gap:12px">
      <div><strong>Start bench:</strong> ${names[currentState.startBench]}</div>
      <div class="small muted">Bench rotates each game: bench = (start + gameIndex) % 5. Each player sits out for one game as the bench rotates every game.</div>
      </div>`;
    frag.appendChild(benchCard);

    // games grid
    const gamesGrid = document.createElement('div');
    gamesGrid.className = 'games';

    currentState.schedule.forEach((gobj, idx) => {
      const div = document.createElement('div');
      div.className = 'game';
      const benchName = names[gobj.bench];
      const teamA = gobj.pairs[0].map(i=>names[i]).join(' + ');
      const teamB = gobj.pairs[1].map(i=>names[i]).join(' + ');

      const h = document.createElement('h3');
      h.textContent = `Game ${idx+1} — Bench: ${benchName}`;
      div.appendChild(h);

      const pairRow = document.createElement('div');
      pairRow.className = 'pair';

      const left = document.createElement('div');
      left.className = 'team';
      left.innerHTML = `<div>${teamA}</div><div class="small muted">(${gobj.pairs[0].map(i=>'P'+(i+1)).join(',')})</div>`;
      pairRow.appendChild(left);

      const mid = document.createElement('div');
      mid.style.display='flex';mid.style.flexDirection='column';mid.style.gap='8px';mid.style.alignItems='center';
      const scoreLabel = document.createElement('div');
      scoreLabel.textContent = `${gobj.scores[0]} — ${gobj.scores[1]}`;
      scoreLabel.style.fontWeight='700';
      mid.appendChild(scoreLabel);

      const controls = document.createElement('div');
      controls.className = 'score-controls';

      const incA = document.createElement('button'); incA.textContent = '+1 A';
      incA.onclick = ()=>{ if(!gobj.finished){ gobj.scores[0] = Math.min(3,gobj.scores[0]+1); checkFinish(idx); renderSchedule(); } };
      const incB = document.createElement('button'); incB.textContent = '+1 B';
      incB.onclick = ()=>{ if(!gobj.finished){ gobj.scores[1] = Math.min(3,gobj.scores[1]+1); checkFinish(idx); renderSchedule(); } };
      const undo = document.createElement('button'); undo.textContent = 'undo'; undo.className='secondary';
      undo.onclick = ()=>{ if(!gobj.finished){ gobj.scores = [0,0]; renderSchedule(); } };

      controls.appendChild(incA); controls.appendChild(incB); controls.appendChild(undo);
      mid.appendChild(controls);

      pairRow.appendChild(mid);

      const right = document.createElement('div');
      right.className = 'team';
      right.innerHTML = `<div>${teamB}</div><div class="small muted">(${gobj.pairs[1].map(i=>'P'+(i+1)).join(',')})</div>`;
      pairRow.appendChild(right);

      div.appendChild(pairRow);

      // small footer with finished status and buttons
      const footer = document.createElement('div');
      footer.style.display='flex'; footer.style.alignItems='center'; footer.style.justifyContent='space-between';
      const status = document.createElement('div');
      status.className = 'small muted';
      if(gobj.finished){
        const winner = gobj.scores[0] > gobj.scores[1] ? 'A' : 'B';
        status.innerHTML = `<strong>Finished</strong> — Winner: ${winner} (${gobj.scores[0]}–${gobj.scores[1]})`;
      } else {
        status.innerHTML = `<span class="small muted">In progress or not started</span>`;
      }
      footer.appendChild(status);

      const buttons = document.createElement('div');
      buttons.style.display='flex'; buttons.style.gap='8px';

      const setFinished = document.createElement('button'); setFinished.className='secondary'; setFinished.textContent='Mark finished';
      setFinished.onclick = ()=>{ if(!gobj.finished){ // if someone already has 3 allow marking; else ask
          if(gobj.scores[0]===3 || gobj.scores[1]===3){
            checkFinish(idx); renderSchedule();
          } else {
            if(confirm('No team has reached 3 yet. Mark finished anyway?')){
              gobj.finished = true;
              updatePlayerStats();
              renderSchedule();
            }
          }
        }
      };

      const editBtn = document.createElement('button'); editBtn.className='secondary'; editBtn.textContent='Edit';
      editBtn.onclick = ()=>{ // quick edit prompt
        const a = prompt('Team A games (0-3)', gobj.scores[0]);
        const b = prompt('Team B games (0-3)', gobj.scores[1]);
        const na = parseInt(a||'0',10), nb = parseInt(b||'0',10);
        if(Number.isFinite(na) && Number.isFinite(nb) && na>=0 && nb>=0 && na<=3 && nb<=3){
          gobj.scores = [na,nb];
          gobj.finished = (na===3||nb===3);
          updatePlayerStats();
          renderSchedule();
        } else alert('Invalid values');
      };

      buttons.appendChild(setFinished); buttons.appendChild(editBtn);
      footer.appendChild(buttons);

      div.appendChild(footer);

      // update score label and style
      scoreLabel.textContent = `${gobj.scores[0]} — ${gobj.scores[1]}`;
      if(gobj.finished){
        div.style.border = '1px solid rgba(0,255,170,0.08)';
        div.style.opacity = '0.92';
      } else {
        div.style.border = '1px solid rgba(255,255,255,0.02)';
        div.style.opacity = '1';
      }

      gamesGrid.appendChild(div);
    });

    frag.appendChild(gamesGrid);
    scheduleArea.appendChild(frag);
    updatePlayerStats();
  }

  function checkFinish(gameIndex){
    const g = currentState.schedule[gameIndex];
    if(g.finished) return;
    if(g.scores[0]===3 || g.scores[1]===3){
      g.finished = true;
      updatePlayerStats();
    }
  }

  function updatePlayerStats(){
    // reset
    currentState.players = Array.from({length:5}, ()=>({gamesWon:0, matchesPlayed:0}));
    // For each finished match, add games won to each player on the teams and increment matchesPlayed
    currentState.schedule.forEach(g=>{
      if(g.finished){
        const aGames = g.scores[0], bGames = g.scores[1];
        const pa = g.pairs[0], pb = g.pairs[1];
        pa.forEach(i=>{ currentState.players[i].gamesWon += aGames; currentState.players[i].matchesPlayed += 1; });
        pb.forEach(i=>{ currentState.players[i].gamesWon += bGames; currentState.players[i].matchesPlayed += 1; });
      }
    });
    // render leaderboard
    leaderboardDiv.innerHTML = '';
    leaderboardCard.style.display = 'block';
    const names = currentState.names;
    // sort by gamesWon desc, tie break by matchesPlayed asc then name
    const ranking = currentState.players.map((p,i)=>({idx:i, name:names[i], ...p}))
      .sort((a,b)=> b.gamesWon - a.gamesWon || a.matchesPlayed - b.matchesPlayed || a.name.localeCompare(b.name));
    ranking.forEach(r=>{
      const el = document.createElement('div');
      el.className = 'p';
      el.innerHTML = `<div><strong>${r.name}</strong></div><div class="small muted">Games won: ${r.gamesWon} • Matches played: ${r.matchesPlayed}</div>`;
      leaderboardDiv.appendChild(el);
    });
  }

  // Generate, regenerate, reset, export/import handlers
  function generateHandler(){
    refreshStartOptions();
    const startBench = parseInt(startBenchSelect.value,10);
    const st = buildNewState(startBench);
    if(!st) return;
    currentState = st;
    // save to localStorage
    localStorage.setItem('padel_state', JSON.stringify(currentState));
    renderSchedule();
  }

  function regenHandler(){
    // regenerate with random start bench
    refreshStartOptions();
    const randomStart = Math.floor(Math.random()*5);
    startBenchSelect.value = randomStart;
    generateHandler();
  }

  function resetScores(){
    if(!currentState) return;
    if(!confirm('Reset all scores and finished flags?')) return;
    currentState.schedule.forEach(g=>{ g.scores=[0,0]; g.finished=false; });
    currentState.players = Array.from({length:5}, ()=>({gamesWon:0,matchesPlayed:0}));
    localStorage.setItem('padel_state', JSON.stringify(currentState));
    renderSchedule();
  }

  function exportJSON(){
    if(!currentState) return alert('No schedule to export');
    const blob = new Blob([JSON.stringify(currentState,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'padel_schedule.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(){
    const input = document.createElement('input');
    input.type='file'; input.accept='application/json';
    input.onchange = (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = (ev)=>{
        try{
          const data = JSON.parse(ev.target.result);
          // Basic validation
          if(!data.names || !Array.isArray(data.schedule)) throw new Error('Invalid format');
          currentState = data;
          localStorage.setItem('padel_state', JSON.stringify(currentState));
          // populate player inputs
          for(let i=0;i<5;i++){ pEls[i].value = currentState.names[i] || pEls[i].placeholder; }
          refreshStartOptions();
          startBenchSelect.value = currentState.startBench || 0;
          renderSchedule();
        }catch(err){
          alert('Failed to import JSON: '+err.message);
        }
      };
      reader.readAsText(f);
    };
    input.click();
  }

  // load from localStorage on start
  function tryRestore(){
    const raw = localStorage.getItem('padel_state');
    if(raw){
      try{
        const data = JSON.parse(raw);
        if(data && data.names && Array.isArray(data.schedule)){
          currentState = data;
          // ensure names fill inputs
          for(let i=0;i<5;i++) pEls[i].value = currentState.names[i] || pEls[i].placeholder;
          refreshStartOptions();
          startBenchSelect.value = currentState.startBench || 0;
          renderSchedule();
          return;
        }
      }catch(e){}
    }
    refreshStartOptions();
  }

  // wire events
  generateBtn.onclick = generateHandler;
  regenBtn.onclick = regenHandler;
  resetBtn.onclick = resetScores;
  exportBtn.onclick = exportJSON;
  importBtn.onclick = importJSON;

  // wire name changes to refresh start options
  pEls.forEach(e=> e.addEventListener('input', ()=> refreshStartOptions()));

  // initial restore
  tryRestore();

  // expose for debugging in console
  window._padel = {getState: ()=>currentState, regenerate: regenHandler};

})();
</script>
</body>
</html>
