<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Padel Game Manager</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
  body {
    margin: 0; padding: 0;
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, #dba458, #70421f);
    color: #fff;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    text-align: center;
    margin: 1rem 0 0.5rem 0;
    font-weight: 700;
    font-size: 1.8rem;
    text-shadow: 0 0 6px #b87532;
  }
  main {
    width: 95vw;
    max-width: 900px;
    background: rgba(30,15,5,0.75);
    border-radius: 12px;
    box-shadow: 0 0 15px #b8741d;
    padding: 15px 20px 30px 20px;
    margin-bottom: 40px;
  }
  label {
    display: block;
    margin-top: 10px;
    font-weight: 600;
  }
  select, input[type=text] {
    padding: 6px 8px;
    border-radius: 6px;
    border: none;
    font-size: 1rem;
    margin-top: 4px;
    width: 100%;
    max-width: 280px;
  }
  button {
    margin-top: 12px;
    background: linear-gradient(45deg, #e6ba4b, #a9691b);
    border: none;
    color: #fff;
    font-weight: 700;
    padding: 10px 18px;
    font-size: 1.1rem;
    border-radius: 30px;
    cursor: pointer;
    box-shadow: 0 0 12px #e6ba4b;
    display: inline-flex;
    align-items: center;
  }
  button:hover {
    background: linear-gradient(45deg, #f0ca66, #c37f29);
    box-shadow: 0 0 18px #f0ca66;
  }
  button svg {
    width: 20px; height: 20px; margin-right: 8px;
    fill: #fff;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 14px;
    font-size: 0.9rem;
  }
  thead {
    background: rgba(184, 135, 37, 0.9);
    font-weight: 700;
  }
  th, td {
    padding: 6px 8px;
    text-align: center;
    border: 1px solid #b87f16;
    vertical-align: middle;
  }
  tbody tr:nth-child(odd) {
    background: rgba(255 255 255 / 0.05);
  }
  input.score-input {
    width: 40px;
    text-align: center;
    font-weight: 600;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    background: rgba(255 255 255 / 0.15);
    color: #fff;
  }
  input.score-input:focus {
    outline: 2px solid #e6ba4b;
    background: rgba(255 255 255 / 0.3);
  }
  .flex-row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: flex-end;
    margin-top: 8px;
  }
  .player-input {
    flex: 1 1 140px;
  }
  .score-entry {
    margin-top: 14px;
    padding-top: 12px;
    border-top: 1px solid #b87f16;
  }
  .leaderboard-container, .match-history-container, .score-entry-container {
    margin-top: 20px;
  }
  .toggle-persist {
    margin-top: 14px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }
  .reset-btn {
    margin-top: 16px;
    background: #b85418;
    box-shadow: 0 0 14px #b85418;
  }
  .reset-btn:hover {
    background: #e6701e;
    box-shadow: 0 0 18px #e6701e;
  }
  footer {
    margin-top: auto;
    padding: 12px;
    font-size: 0.9rem;
    color: #b8974f;
    text-align: center;
  }
  /* Scroll horizontal for tables on small */
  .scroll-table {
    overflow-x: auto;
  }
  /* Responsive */
  @media (max-width: 520px) {
    .flex-row {
      flex-direction: column;
      align-items: stretch;
    }
    input.score-input {
      width: 100%;
      max-width: 100%;
    }
  }
</style>
</head>
<body>
<header>Padel Game Manager</header>
<main>

<div id="setup-screen">
  <label for="player-count">Number of players:</label>
  <select id="player-count">
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>
  <div id="player-names-inputs" style="margin-top:10px;">
    <!-- Dynamic inputs for player names -->
  </div>
  <button id="start-session-btn">Start Session</button>
</div>

<div id="app-screen" style="display:none;">
  
  <section class="score-entry-container">
    <h2>Enter Game Scores</h2>
    <div id="current-match-number" style="font-weight:700; margin-bottom:8px;"></div>
    <div id="score-entry-fields" class="flex-row">
      <!-- Dynamic score inputs -->
    </div>
    <button id="save-score-btn">Save Score</button>
    <label class="toggle-persist">
      <input type="checkbox" id="persist-scores" checked /> Persist scores (local storage)
    </label>
    <button id="reset-session-btn" class="reset-btn">Reset Session</button>
  </section>

  <section class="leaderboard-container">
    <h2>Leaderboard</h2>
    <div class="scroll-table">
      <table id="leaderboard-table">
        <thead>
          <tr>
            <th>Player</th>
            <th>Points</th>
            <th>Games Played</th>
            <th>Points/Game</th>
          </tr>
        </thead>
        <tbody>
          <!-- Dynamic leaderboard rows -->
        </tbody>
      </table>
    </div>
  </section>

  <section class="match-history-container">
    <h2>Match History</h2>
    <button id="export-csv-btn" title="Export match history as CSV">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-18L5.33 9h3.67v6h4v-6h3.67L12 2z"/></svg>
      Download CSV
    </button>
    <div class="scroll-table" style="margin-top: 10px;">
      <table id="match-history-table">
        <thead>
          <tr>
            <th>Match #</th>
            <th>Date/Time</th>
            <th>Double 1 Player A</th>
            <th>Double 1 Player B</th>
            <th>Double 2 Player A</th>
            <th>Double 2 Player B</th>
            <th>Score Double 1</th>
            <th>Score Double 2</th>
            <th>Points Player A</th>
            <th>Points Player B</th>
            <th>Points Player C</th>
            <th>Points Player D</th>
            <th>Player Out</th>
          </tr>
        </thead>
        <tbody>
          <!-- Dynamic match history rows -->
        </tbody>
      </table>
    </div>
  </section>

</div>

</main>
<footer>Padel Manager © 2025 — Powered by Your Desert Padel</footer>

<script>
(() => {
  // State
  let players = [];
  let numPlayers = 5;
  let matches = [];
  let currentMatchIndex = 0;
  let persistScores = true;

  const setupScreen = document.getElementById('setup-screen');
  const appScreen = document.getElementById('app-screen');
  const playerCountSelect = document.getElementById('player-count');
  const playerNamesInputsDiv = document.getElementById('player-names-inputs');
  const startSessionBtn = document.getElementById('start-session-btn');

  const currentMatchNumberDiv = document.getElementById('current-match-number');
  const scoreEntryFieldsDiv = document.getElementById('score-entry-fields');
  const saveScoreBtn = document.getElementById('save-score-btn');
  const persistCheckbox = document.getElementById('persist-scores');
  const resetSessionBtn = document.getElementById('reset-session-btn');

  const leaderboardTableBody = document.querySelector('#leaderboard-table tbody');
  const matchHistoryTableBody = document.querySelector('#match-history-table tbody');
  const exportCsvBtn = document.getElementById('export-csv-btn');

  // Initialize player name inputs on setup screen
  function renderPlayerNameInputs() {
    playerNamesInputsDiv.innerHTML = '';
    const count = parseInt(playerCountSelect.value);
    for(let i=0; i < count; i++) {
      const label = document.createElement('label');
      label.textContent = `Player ${i+1} Name:`;
      label.setAttribute('for', `player-name-${i}`);
      const input = document.createElement('input');
      input.type = 'text';
      input.id = `player-name-${i}`;
      input.value = `Player${i+1}`;
      input.required = true;
      input.classList.add('player-input');
      playerNamesInputsDiv.appendChild(label);
      playerNamesInputsDiv.appendChild(input);
    }
  }

  playerCountSelect.addEventListener('change', () => {
    renderPlayerNameInputs();
  });

  // Utility shuffle function
  function shuffleArray(arr) {
    const a = arr.slice();
    for(let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Generate matches for 5 players mode (15 matches total)
  // Rotations as per original rules
  function generateMatchesFive(players) {
    // Generate all possible doubles (pairs)
    let doubles = [];
    for(let i=0; i<players.length; i++) {
      for(let j=i+1; j<players.length; j++) {
        doubles.push([players[i], players[j]]);
      }
    }
    // Total doubles = 10 for 5 players
    // Generate all pairs of doubles that are disjoint and one player out
    let candidateMatches = [];
    for(let i=0; i<doubles.length; i++) {
      for(let j=i+1; j<doubles.length; j++) {
        const d1 = doubles[i];
        const d2 = doubles[j];
        const allPlayers = [...d1, ...d2];
        const uniquePlayers = new Set(allPlayers);
        if(uniquePlayers.size === 4) {
          // Identify player out (5th player)
          const outPlayer = players.find(p => !uniquePlayers.has(p));
          candidateMatches.push({double1: d1, double2: d2, playerOut: outPlayer});
        }
      }
    }
    // We want a schedule of 15 matches where each player plays 4 games, no same doubles consecutive,
    // and rotate who is out every 4 games.
    // We'll randomize order, then check constraints in simplified way:
    // Shuffle candidateMatches until one fits constraints or up to max tries

    function validateSchedule(schedule) {
      // Check playerOut rotation: every 4 games same playerOut, then rotate
      for(let i=0; i<schedule.length; i++) {
        let expectedOutPlayer = schedule[ Math.floor(i/4)*4 ].playerOut;
        if(schedule[i].playerOut !== expectedOutPlayer) return false;
      }
      // Check no same doubles play twice consecutively
      for(let i=1; i<schedule.length; i++) {
        const prev = schedule[i-1];
        const curr = schedule[i];
        if(sameDoubles(prev, curr)) return false;
      }
      return true;
    }

    function sameDoubles(m1, m2) {
      const setsEqual = (a,b) => a.length === b.length && a.every(v => b.includes(v));
      return (setsEqual(m1.double1, m2.double1) && setsEqual(m1.double2, m2.double2)) ||
             (setsEqual(m1.double1, m2.double2) && setsEqual(m1.double2, m2.double1));
    }

    let schedule = [];
    let tries = 0;
    const MAX_TRIES = 20000;
    while(tries < MAX_TRIES) {
      const shuffled = shuffleArray(candidateMatches);
      if(shuffled.length < 15) return shuffled; // safety fallback
      let possible = shuffled.slice(0,15);
      if(validateSchedule(possible)) {
        schedule = possible;
        break;
      }
      tries++;
    }
    if(schedule.length === 0) {
      // fallback: just first 15 candidate matches (may violate rules)
      schedule = candidateMatches.slice(0,15);
    }
    // Add timestamps and empty scores
    return schedule.map((m, idx) => ({
      id: idx+1,
      datetime: new Date().toISOString(),
      double1: m.double1,
      double2: m.double2,
      playerOut: m.playerOut,
      scoreD1: null,
      scoreD2: null,
      pointsPerPlayer: {}
    }));
  }

  // Generate matches for 4 players mode
  // Rotate doubles, no repeats consecutive, try all combinations evenly
  function generateMatchesFour(players) {
    // Possible doubles (6 pairs)
    let doubles = [];
    for(let i=0; i<players.length; i++) {
      for(let j=i+1; j<players.length; j++) {
        doubles.push([players[i], players[j]]);
      }
    }
    // Schedule matches of two doubles with no player overlap and no consecutive same doubles
    // Generate all possible matches for 4 players: only 3 combos possible (since only 4 players)
    // Pairs:
    // Match combos:
    // [0,5], [1,4], [2,3]
    // We'll repeat those 3 matches several times (say 15 matches total)

    const possibleMatches = [
      {double1: doubles[0], double2: doubles[5]}, // players 0&1 vs 2&3
      {double1: doubles[1], double2: doubles[4]}, // players 0&2 vs 1&3
      {double1: doubles[2], double2: doubles[3]}  // players 0&3 vs 1&2
    ];
    // Create a schedule by repeating those matches 5 times (15 matches)
    let schedule = [];
    for(let i=0; i<15; i++) {
      const match = possibleMatches[i % possibleMatches.length];
      schedule.push({
        id: i+1,
        datetime: new Date().toISOString(),
        double1: match.double1,
        double2: match.double2,
        playerOut: null,
        scoreD1: null,
        scoreD2: null,
        pointsPerPlayer: {}
      });
    }
    return schedule;
  }

  // Calculate leaderboard points and games played from matches
  function calculateLeaderboard() {
    let stats = {};
    players.forEach(p => stats[p] = {points:0, gamesPlayed:0});
    matches.forEach(match => {
      if(match.scoreD1 === null || match.scoreD2 === null) return; // skip no score
      // Add points for double 1 players
      match.double1.forEach(p => {
        stats[p].points += match.scoreD1;
        stats[p].gamesPlayed++;
      });
      // Add points for double 2 players
      match.double2.forEach(p => {
        stats[p].points += match.scoreD2;
        stats[p].gamesPlayed++;
      });
    });
    // Add index: points/gamesPlayed (handle div 0)
    Object.keys(stats).forEach(p => {
      let sp = stats[p];
      sp.index = sp.gamesPlayed ? (sp.points / sp.gamesPlayed) : 0;
    });
    return stats;
  }

  // Render leaderboard table sorted by points desc, then index desc
  function renderLeaderboard() {
    const stats = calculateLeaderboard();
    // Sort players by points desc then index desc
    const sorted = Object.entries(stats).sort((a,b) => {
      if(b[1].points !== a[1].points) return b[1].points - a[1].points;
      return b[1].index - a[1].index;
    });
    leaderboardTableBody.innerHTML = '';
    sorted.forEach(([p, s]) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${p}</td>
        <td>${s.points}</td>
        <td>${s.gamesPlayed}</td>
        <td>${s.index.toFixed(2)}</td>
      `;
      leaderboardTableBody.appendChild(tr);
    });
  }

  // Render match history table
  function renderMatchHistory() {
    matchHistoryTableBody.innerHTML = '';
    matches.forEach(match => {
      const tr = document.createElement('tr');
      // Points per player cells (4 or 5 players)
      const ptsCells = players.map(p => {
        const val = match.pointsPerPlayer[p];
        return `<td>${val != null ? val : ''}</td>`;
      }).join('');
      tr.innerHTML = `
        <td>${match.id}</td>
        <td>${new Date(match.datetime).toLocaleString()}</td>
        <td>${match.double1[0]}</td>
        <td>${match.double1[1]}</td>
        <td>${match.double2[0]}</td>
        <td>${match.double2[1]}</td>
        <td>${match.scoreD1 != null ? match.scoreD1 : ''}</td>
        <td>${match.scoreD2 != null ? match.scoreD2 : ''}</td>
        ${ptsCells}
        <td>${match.playerOut || ''}</td>
      `;
      matchHistoryTableBody.appendChild(tr);
    });
  }

  // Render score entry inputs for current match
  function renderScoreEntry() {
    if(currentMatchIndex >= matches.length) {
      scoreEntryFieldsDiv.innerHTML = '<em>All matches completed.</em>';
      currentMatchNumberDiv.textContent = '';
      saveScoreBtn.disabled = true;
      return;
    }
    const match = matches[currentMatchIndex];
    currentMatchNumberDiv.textContent = `Match #${match.id} - ${match.double1.join(' & ')} vs ${match.double2.join(' & ')}`;
    saveScoreBtn.disabled = false;
    scoreEntryFieldsDiv.innerHTML = '';

    const createScoreInput = (labelText, initialValue, id) => {
      const div = document.createElement('div');
      div.style.textAlign = 'center';
      const label = document.createElement('label');
      label.textContent = labelText;
      label.setAttribute('for', id);
      label.style.fontWeight = '600';
      label.style.display = 'block';
      label.style.marginBottom = '4px';
      const input = document.createElement('input');
      input.type = 'number';
      input.min = 0;
      input.max = 3;
      input.id = id;
      input.className = 'score-input';
      input.value = initialValue != null ? initialValue : '';
      input.setAttribute('inputmode', 'numeric');
      input.required = true;
      div.appendChild(label);
      div.appendChild(input);
      return div;
    };

    scoreEntryFieldsDiv.appendChild(createScoreInput(`Score for ${match.double1.join(' & ')}`, match.scoreD1, 'scoreD1'));
    scoreEntryFieldsDiv.appendChild(createScoreInput(`Score for ${match.double2.join(' & ')}`, match.scoreD2, 'scoreD2'));
  }

  // Calculate points per player for a match
  function calcPointsPerPlayer(match) {
    if(match.scoreD1 == null || match.scoreD2 == null) {
      match.pointsPerPlayer = {};
      return;
    }
    const pts = {};
    match.double1.forEach(p => pts[p] = match.scoreD1);
    match.double2.forEach(p => pts[p] = match.scoreD2);
    if(match.playerOut) pts[match.playerOut] = null;
    match.pointsPerPlayer = pts;
  }

  // Save score from inputs for current match and move to next
  function saveScore() {
    if(currentMatchIndex >= matches.length) return;
    const s1 = parseInt(document.getElementById('scoreD1').value);
    const s2 = parseInt(document.getElementById('scoreD2').value);
    if(isNaN(s1) || isNaN(s2)) {
      alert('Please enter numeric scores for both doubles.');
      return;
    }
    if(s1 < 0 || s2 < 0 || s1 > 3 || s2 > 3) {
      alert('Scores must be between 0 and 3.');
      return;
    }
    matches[currentMatchIndex].scoreD1 = s1;
    matches[currentMatchIndex].scoreD2 = s2;
    calcPointsPerPlayer(matches[currentMatchIndex]);
    currentMatchIndex++;
    persistData();
    renderScoreEntry();
    renderLeaderboard();
    renderMatchHistory();
  }

  // Persist to localStorage if toggle is on
  function persistData() {
    if(!persistScores) return;
    const data = {
      players,
      numPlayers,
      matches,
      currentMatchIndex
    };
    localStorage.setItem('padelManagerData', JSON.stringify(data));
  }

  // Load from localStorage
  function loadData() {
    const dataRaw = localStorage.getItem('padelManagerData');
    if(!dataRaw) return false;
    try {
      const data = JSON.parse(dataRaw);
      if(!data.players || !data.matches) return false;
      players = data.players;
      numPlayers = data.numPlayers;
      matches = data.matches;
      currentMatchIndex = data.currentMatchIndex || 0;
      return true;
    } catch {
      return false;
    }
  }

  // Reset session
  function resetSession() {
    if(confirm('Reset session? All data will be lost.')) {
      localStorage.removeItem('padelManagerData');
      location.reload();
    }
  }

  // Export CSV logic
  function exportCSV() {
    if(matches.length === 0) {
      alert('No matches to export.');
      return;
    }
    // Build header
    const header = [
      'Match #',
      'Date/Time',
      'Double 1 Player A',
      'Double 1 Player B',
      'Double 2 Player A',
      'Double 2 Player B',
      'Score Double 1',
      'Score Double 2',
      ...players,
      numPlayers === 5 ? 'Player Out' : ''
    ].filter(Boolean);

    // Rows
    const rows = matches.map(m => {
      const base = [
        m.id,
        new Date(m.datetime).toLocaleString(),
        m.double1[0],
        m.double1[1],
        m.double2[0],
        m.double2[1],
        m.scoreD1 != null ? m.scoreD1 : '',
        m.scoreD2 != null ? m.scoreD2 : ''
      ];
      // Points per player, blank if none
      const pts = players.map(p => {
        const val = m.pointsPerPlayer ? m.pointsPerPlayer[p] : null;
        return val != null ? val : '';
      });
      const outP = numPlayers === 5 ? (m.playerOut || '') : '';
      return [...base, ...pts, outP];
    });

    // CSV string with proper escaping
    function escapeCSV(val) {
      if(val == null) return '';
      val = val.toString();
      if(val.includes(',') || val.includes('"') || val.includes('\n')) {
        return `"${val.replace(/"/g, '""')}"`;
      }
      return val;
    }

    const csvContent = [header, ...rows].map(row => row.map(escapeCSV).join(',')).join('\n');

    // Trigger download
    const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth()+1).padStart(2,'0');
    const dd = String(today.getDate()).padStart(2,'0');
    a.download = `padel_history_${yyyy}-${mm}-${dd}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Setup start session button handler
  startSessionBtn.addEventListener('click', () => {
    // Collect player names
    const inputs = playerNamesInputsDiv.querySelectorAll('input[type=text]');
    const names = [];
    for(let input of inputs) {
      const val = input.value.trim();
      if(!val) {
        alert('Please enter all player names.');
        return;
      }
      names.push(val);
    }
    players = names;
    numPlayers = players.length;
    // Generate matches based on player count
    if(numPlayers === 5) {
      matches = generateMatchesFive(players);
    } else if(numPlayers === 4) {
      matches = generateMatchesFour(players);
    } else {
      alert('Only 4 or 5 players supported.');
      return;
    }
    currentMatchIndex = 0;
    persistScores = persistCheckbox.checked;
    setupScreen.style.display = 'none';
    appScreen.style.display = 'block';
    renderLeaderboard();
    renderMatchHistory();
    renderScoreEntry();
  });

  // Save score button
  saveScoreBtn.addEventListener('click', () => {
    saveScore();
  });

  // Persist toggle
  persistCheckbox.addEventListener('change', (e) => {
    persistScores = e.target.checked;
    if(!persistScores) {
      localStorage.removeItem('padelManagerData');
    } else {
      persistData();
    }
  });

  // Reset session button
  resetSessionBtn.addEventListener('click', () => {
    resetSession();
  });

  // Export CSV button
  exportCsvBtn.addEventListener('click', () => {
    exportCSV();
  });

  // On load, try to restore session
  window.addEventListener('load', () => {
    if(loadData()) {
      setupScreen.style.display = 'none';
      appScreen.style.display = 'block';
      renderLeaderboard();
      renderMatchHistory();
      renderScoreEntry();
    } else {
      renderPlayerNameInputs();
    }
  });

  renderPlayerNameInputs();

})();
</script>
</body>
</html>