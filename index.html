<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Padel Manager - Scheduler & Scoring</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600&display=swap');
    body {
      margin: 0; padding: 20px;
      background: linear-gradient(135deg, #42291a 0%, #f5d68f 100%);
      font-family: 'Rajdhani', sans-serif;
      color: #2c1b0f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }
    h1 {
      margin-bottom: 5px;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
    }
    label, select, input, button {
      font-size: 1.1rem;
      margin: 5px 0;
      border-radius: 6px;
    }
    select, input[type=text], input[type=number] {
      padding: 8px 10px;
      border: none;
      width: 280px;
      box-sizing: border-box;
      outline: none;
      border: 2px solid #c3a66d;
      background: #fff9e1;
      color: #4d3b1b;
      transition: border-color 0.3s ease;
    }
    select:focus, input[type=text]:focus, input[type=number]:focus {
      border-color: #8a5a21;
    }
    button {
      background: #8a5a21;
      color: #f2e4c9;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(138, 90, 33, 0.6);
      transition: background-color 0.3s ease;
      user-select: none;
    }
    button:hover {
      background: #6b4413;
    }
    table {
      margin-top: 25px;
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
      background: #f5d68f;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      user-select: text;
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      border-bottom: 1px solid #c3a66d;
      font-weight: 600;
      color: #4d3b1b;
    }
    th {
      background: #8a5a21;
      color: #f2e4c9;
      user-select: none;
    }
    input.score-input {
      width: 48px;
      padding: 6px 4px;
      font-size: 1rem;
      text-align: center;
      border: 2px solid #c3a66d;
      border-radius: 6px;
      background: #fff9e1;
      color: #4d3b1b;
    }
    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #matchList {
      max-height: 300px;
      overflow-y: auto;
    }
    #exportCsvBtn {
      margin-top: 15px;
      background: #6b4413;
    }
    #persistenceToggle {
      margin-left: 8px;
      vertical-align: middle;
      transform: scale(1.2);
      cursor: pointer;
      display: none; /* Hide, we won't use localStorage persistence */
    }
    #scoreboard {
      margin-top: 25px;
      max-width: 600px;
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      background: #f5d68f;
      padding: 10px 0;
    }
    #scoreboard table {
      width: 100%;
      border-collapse: collapse;
    }

    /* Auth UI */
    #authContainer {
      display: flex;
      flex-direction: column;
      max-width: 320px;
      width: 100%;
      margin-bottom: 20px;
    }
    #authContainer input {
      margin-bottom: 10px;
      font-size: 1rem;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #c3a66d;
      outline: none;
    }
    #authContainer button {
      margin-bottom: 10px;
    }
    #authMessage {
      min-height: 1.2em;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
      font-weight: 600;
      text-align: center;
    }
  </style>
</head>
<body>

<div id="authContainer">
  <input id="emailInput" type="email" placeholder="Email" />
  <input id="passwordInput" type="password" placeholder="Password" />
  <button id="loginBtn">Login</button>
  <button id="signupBtn">Sign Up</button>
  <p id="authMessage"></p>
</div>

<div id="mainContainer" class="container" style="display:none;">
  <h1>Padel Manager</h1>

  <label for="gameSetSelect">Select Game Set (by date):</label>
  <select id="gameSetSelect"></select>
  <button id="newSetBtn">New Set for Today</button>

  <label for="playerCount">Select Players (no mid-session switch):</label>
  <select id="playerCount" disabled>
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>

  <label for="playerNames">Enter Player Names (comma separated):</label>
  <input id="playerNames" type="text" placeholder="Alice,Bob,Charlie,David,Eva" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled>

  <label for="rounds">Number of rounds (games):</label>
  <input id="rounds" type="number" min="1" value="15" disabled />

  <button id="generateBtn" disabled>Generate Schedule</button>

  <div id="scheduleOutput"></div>

  <div id="scoreboard"></div>

  <h2>Match History (editable scores)</h2>
  <div id="matchList"></div>

  <button id="exportCsvBtn">Export Matches CSV</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const supabaseUrl = 'https://vgcvemwzqyqwlwckoafu.supabase.co';
  const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZnY3ZlbXd6cXlxd2x3Y2tvYWZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDk4NDIsImV4cCI6MjA3MDU4NTg0Mn0.zs5403wZkhPU1JU9AV0FVRUD_WBdf2oDV-eoKHmT-2U';
  const sb = supabase.createClient(supabaseUrl, supabaseAnonKey);

    // Elements
    const loginSection = document.getElementById('loginSection');
    const emailInput = document.getElementById('emailInput');
    const passwordInput = document.getElementById('passwordInput');
    const loginBtn = document.getElementById('loginBtn');
    const signUpBtn = document.getElementById('signUpBtn');
    const loginMessage = document.getElementById('loginMessage');

    const appSection = document.getElementById('appSection');
    const logoutBtn = document.getElementById('logoutBtn');
    const gameSetSelect = document.getElementById('gameSetSelect');
    const newGameSetBtn = document.getElementById('newGameSetBtn');
    const playerCountSelect = document.getElementById('playerCount');
    const playerNamesInput = document.getElementById('playerNames');
    const roundsInput = document.getElementById('rounds');
    const generateBtn = document.getElementById('generateBtn');
    const editableToggle = document.getElementById('editableToggle');
    const scheduleOutput = document.getElementById('scheduleOutput');
    const scoreboardDiv = document.getElementById('scoreboard');
    const matchListDiv = document.getElementById('matchList');
    const exportCsvBtn = document.getElementById('exportCsvBtn');

    // State
    let user = null;
    let gameSets = [];
    let currentGameSet = null; // {id, date, editable}
    let schedule = [];
    let scores = [];
    let players = [];
    let playerCount = 5;
    let rounds = 15;
    let playerStats = {};

    // Helper to format Date YYYY-MM-DD
    function formatDate(d) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }

    // Login / Signup
    async function signIn(email, password) {
      loginMessage.textContent = '';
      const { data, error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) {
        loginMessage.textContent = 'Login failed: ' + error.message;
        return null;
      }
      return data.user;
    }

    async function signUp(email, password) {
      loginMessage.textContent = '';
      const { data, error } = await supabase.auth.signUp({ email, password });
      if (error) {
        loginMessage.textContent = 'Signup failed: ' + error.message;
        return null;
      }
      loginMessage.textContent = 'Signup success. Please check your email for confirmation.';
      return data.user;
    }

    async function signOut() {
      await supabase.auth.signOut();
      user = null;
      currentGameSet = null;
      gameSets = [];
      schedule = [];
      scores = [];
      showLogin();
    }

    // Show login or app section
    function showLogin() {
      loginSection.style.display = 'block';
      appSection.style.display = 'none';
      loginMessage.textContent = '';
    }

    function showApp() {
      loginSection.style.display = 'none';
      appSection.style.display = 'block';
    }

    // Load game sets for user
    async function loadGameSets() {
      if (!user) return;
      const { data, error } = await supabase
        .from('game_sets')
        .select('*')
        .eq('user_id', user.id)
        .order('date', { ascending: false });
      if (error) {
        alert('Error loading game sets: ' + error.message);
        return;
      }
      gameSets = data;
      populateGameSetSelect();
    }

    // Populate dropdown with game sets by date
    function populateGameSetSelect() {
      gameSetSelect.innerHTML = '';
      if (gameSets.length === 0) {
        const opt = document.createElement('option');
        opt.text = 'No game sets found';
        opt.disabled = true;
        gameSetSelect.add(opt);
        currentGameSet = null;
        clearSchedule();
        return;
      }
      gameSets.forEach(gs => {
        const opt = document.createElement('option');
        opt.value = gs.id;
        opt.text = gs.date + (gs.editable ? ' (Editable)' : ' (Locked)');
        gameSetSelect.add(opt);
      });
      // Select first by default
      gameSetSelect.selectedIndex = 0;
      loadSelectedGameSet();
    }

    // Load selected game set and its matches
    async function loadSelectedGameSet() {
      const gsId = gameSetSelect.value;
      if (!gsId) return;
      currentGameSet = gameSets.find(gs => gs.id == gsId);
      if (!currentGameSet) return;

      // Load games for this set
      const { data, error } = await supabase
        .from('games')
        .select('*')
        .eq('game_set_id', gsId)
        .order('match_number', { ascending: true });
      if (error) {
        alert('Error loading games: ' + error.message);
        return;
      }
      // Restore schedule & scores from DB
      // schedule = reconstruct schedule array from DB (teams + rest info)
      schedule = data.map(g => ({
        id: g.match_number,
        team1: JSON.parse(g.team1),
        team2: JSON.parse(g.team2),
        rest: JSON.parse(g.resting_players)
      }));
      scores = data.map(g => ({
        match_number: g.match_number,
        team1_score: g.team1_score,
        team2_score: g.team2_score
      }));

      // Set player count and player names from currentGameSet (stored in JSON columns or text)
      playerCount = currentGameSet.player_count;
      rounds = currentGameSet.rounds;
      players = JSON.parse(currentGameSet.player_names_json);

      playerCountSelect.value = playerCount;
      roundsInput.value = rounds;
      playerNamesInput.value = players.join(',');

      editableToggle.checked = currentGameSet.editable;

      renderSchedule();
      renderScoreboard();
      renderMatchHistory();
    }

    // Clear schedule UI & data
    function clearSchedule() {
      schedule = [];
      scores = [];
      players = [];
      playerCount = 5;
      rounds = 15;
      playerCountSelect.value = playerCount;
      roundsInput.value = rounds;
      playerNamesInput.value = '';
      editableToggle.checked = false;
      scheduleOutput.innerHTML = '';
      scoreboardDiv.innerHTML = '';
      matchListDiv.innerHTML = '';
    }

    // Create new game set for today (only one per day allowed)
    async function createNewGameSet() {
      if (!user) return;
      const today = formatDate(new Date());
      // Check if exists a game_set for today
      const exists = gameSets.find(gs => gs.date === today);
      if (exists) {
        alert("You already have a game set for today. Delete it first to create new.");
        return;
      }
      // Create new empty game set
      const { data, error } = await supabase
        .from('game_sets')
        .insert({
          user_id: user.id,
          date: today,
          editable: true,
          player_count: 5,
          rounds: 15,
          player_names_json: JSON.stringify([])
        })
        .select()
        .single();
      if (error) {
        alert('Error creating game set: ' + error.message);
        return;
      }
      gameSets.unshift(data); // add to list top
      populateGameSetSelect();
      gameSetSelect.value = data.id;
      await loadSelectedGameSet();
    }

    // Save schedule + matches + scores into DB
    async function saveScheduleAndMatches() {
      if (!currentGameSet || !user) return;

      // Validate player names count
      const names = playerNamesInput.value.split(',').map(s => s.trim()).filter(s => s);
      if (!validatePlayerNames(names, playerCountSelect.value)) {
        alert(`Please enter exactly ${playerCountSelect.value} player names.`);
        return;
      }

      players = names;
      playerCount = parseInt(playerCountSelect.value, 10);
      rounds = parseInt(roundsInput.value, 10);

      // Generate schedule using existing functions
      if (playerCount === 4) {
        schedule = scheduleFourPlayers(players, rounds);
      } else if (playerCount === 5) {
        schedule = scheduleFivePlayers(players, rounds);
      }

      // Save game set updated data (players, counts, rounds)
      const { error: updateSetErr } = await supabase
        .from('game_sets')
        .update({
          player_count: playerCount,
          rounds: rounds,
          player_names_json: JSON.stringify(players),
          editable: editableToggle.checked
        })
        .eq('id', currentGameSet.id);
      if (updateSetErr) {
        alert('Error updating game set: ' + updateSetErr.message);
        return;
      }
      currentGameSet.player_count = playerCount;
      currentGameSet.rounds = rounds;
      currentGameSet.player_names_json = JSON.stringify(players);
      currentGameSet.editable = editableToggle.checked;

      // Delete any existing games for this set (so we overwrite)
      const { error: delErr } = await supabase
        .from('games')
        .delete()
        .eq('game_set_id', currentGameSet.id);
      if (delErr) {
        alert('Error deleting old games: ' + delErr.message);
        return;
      }

      // Insert games with empty scores
      for (let match of schedule) {
        const { error: insErr } = await supabase
          .from('games')
          .insert({
            game_set_id: currentGameSet.id,
            match_number: match.id,
            team1: JSON.stringify(match.team1),
            team2: JSON.stringify(match.team2),
            resting_players: JSON.stringify(match.rest),
            team1_score: 0,
            team2_score: 0
          });
        if (insErr) {
          alert('Error inserting game: ' + insErr.message);
          return;
        }
      }

      // Reload matches from DB
      await loadSelectedGameSet();
      alert('Schedule saved!');
    }

    // Save score for a specific match and team
    async function saveScore(matchId, teamNum, val) {
      if (!currentGameSet || !currentGameSet.editable) {
        alert("This game set is locked from editing.");
        loadSelectedGameSet(); // revert UI
        return;
      }
      const parsedVal = parseInt(val, 10);
      if (isNaN(parsedVal) || parsedVal < 0) {
        alert("Score must be a non-negative number.");
        loadSelectedGameSet();
        return;
      }
      // Find existing game record
      const game = schedule.find(m => m.id === matchId);
      if (!game) return;

      // Update score locally
      let scoreEntry = scores.find(s => s.match_number === matchId);
      if (!scoreEntry) {
        scoreEntry = { match_number: matchId, team1_score: 0, team2_score: 0 };
        scores.push(scoreEntry);
      }
      if (teamNum === "1") scoreEntry.team1_score = parsedVal;
      else if (teamNum === "2") scoreEntry.team2_score = parsedVal;

      // Update in DB
      const { error } = await supabase
        .from('games')
        .update({
          team1_score: scoreEntry.team1_score,
          team2_score: scoreEntry.team2_score
        })
        .eq('game_set_id', currentGameSet.id)
        .eq('match_number', matchId);
      if (error) {
        alert('Error updating score: ' + error.message);
        return;
      }
      renderScoreboard();
      renderMatchHistory();
    }

    // Validate player names
    function validatePlayerNames(names, count) {
      if (names.length !== parseInt(count, 10)) return false;
      for (const n of names) if (!n) return false;
      return true;
    }

    // Render schedule UI
    function renderSchedule() {
      if (!schedule.length) {
        scheduleOutput.innerHTML = "<p>No schedule generated.</p>";
        return;
      }
      let html = `<table><thead><tr>
        <th>Match #</th>
        ${playerCount === 5 ? "<th>Resting</th>" : ""}
        <th>Team 1</th><th>Team 2</th><th>Score Team 1</th><th>Score Team 2</th>
      </tr></thead><tbody>`;
      schedule.forEach(match => {
        const restStr = playerCount === 5 ? `<td>${match.rest[0]}</td>` : "";
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        const isEditable = currentGameSet && currentGameSet.editable;
        html += `<tr data-matchid="${match.id}">
          <td>${match.id}</td>
          ${restStr}
          <td>${match.team1.join(" & ")}</td>
          <td>${match.team2.join(" & ")}</td>
          <td><input class="score-input" type="number" min="0" max="10" value="${scoreEntry.team1_score}" data-team="1" data-match="${match.id}" ${!isEditable ? 'disabled' : ''} /></td>
          <td><input class="score-input" type="number" min="0" max="10" value="${scoreEntry.team2_score}" data-team="2" data-match="${match.id}" ${!isEditable ? 'disabled' : ''} /></td>
        </tr>`;
      });
      html += "</tbody></table>";
      scheduleOutput.innerHTML = html;

      if (currentGameSet && currentGameSet.editable) {
        document.querySelectorAll(".score-input").forEach(input => {
          input.onchange = async (e) => {
            const matchId = parseInt(e.target.dataset.match, 10);
            const teamNum = e.target.dataset.team;
            const val = e.target.value;
            await saveScore(matchId, teamNum, val);
          };
        });
      }
    }

    // Render scoreboard UI
    function renderScoreboard() {
      playerStats = calculatePlayerStats(schedule, scores);
      let html = `<table><thead><tr>
        <th>Player</th><th>Points</th><th>Games Played</th><th>Points/Game Index</th>
      </tr></thead><tbody>`;
      Object.entries(playerStats).forEach(([player, stat]) => {
        html += `<tr>
          <td>${player}</td>
          <td>${stat.points}</td>
          <td>${stat.games}</td>
          <td>${stat.index}</td>
        </tr>`;
      });
      html += "</tbody></table>";
      scoreboardDiv.innerHTML = html;
    }

    // Render match history UI
    function renderMatchHistory() {
      if (!schedule.length) {
        matchListDiv.innerHTML = "<p>No matches yet.</p>";
        return;
      }
      let html = `<table><thead><tr>
        <th>Match ID</th>
        <th>Date/Time</th>
        <th>Team 1</th><th>Team 1 Score</th>
        <th>Team 2</th><th>Team 2 Score</th>
        ${playerCount === 5 ? "<th>Resting</th>" : ""}
      </tr></thead><tbody>`;
      schedule.forEach(match => {
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        const dt = new Date().toLocaleString();
        html += `<tr>
          <td>${match.id}</td>
          <td>${dt}</td>
          <td>${match.team1.join(" & ")}</td>
          <td>${scoreEntry.team1_score || ""}</td>
          <td>${match.team2.join(" & ")}</td>
          <td>${scoreEntry.team2_score || ""}</td>
          ${playerCount === 5 ? `<td>${match.rest[0]}</td>` : ""}
        </tr>`;
      });
      html += "</tbody></table>";
      matchListDiv.innerHTML = html;
    }

    // Calculate player stats (points/games/index)
    function calculatePlayerStats(schedule, scores) {
      let stats = {};
      players.forEach(p => {
        stats[p] = { points: 0, games: 0, index: "0.00" };
      });
      scores.forEach(score => {
        let match = schedule.find(m => m.id === score.match_number);
        if (!match) return;
        const t1score = parseInt(score.team1_score, 10) || 0;
        const t2score = parseInt(score.team2_score, 10) || 0;
        match.team1.forEach(p => { stats[p].points += t1score; stats[p].games++; });
        match.team2.forEach(p => { stats[p].points += t2score; stats[p].games++; });
      });
      Object.values(stats).forEach(s => {
        s.index = s.games > 0 ? (s.points / s.games).toFixed(2) : "0.00";
      });
      return stats;
    }

    // Export CSV button handler
    function exportCsv() {
      if (!schedule.length) {
        alert("Generate or select a schedule first.");
        return;
      }
      let csv = [];
      let headers = ["Match ID", "Team1 Player1", "Team1 Player2", "Team1 Score", "Team2 Player1", "Team2 Player2", "Team2 Score"];
      if (playerCount === 5) headers.push("Resting Player");
      csv.push(headers.join(","));

      schedule.forEach(match => {
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        let row = [
          match.id,
          match.team1[0],
          match.team1[1],
          scoreEntry.team1_score || "",
          match.team2[0],
          match.team2[1],
          scoreEntry.team2_score || ""
        ];
        if (playerCount === 5) row.push(match.rest[0]);
        csv.push(row.map(v => `"${v}"`).join(","));
      });

      const csvString = csv.join("\n");
      const blob = new Blob([csvString], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `padel_game_set_${currentGameSet.date}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Event handlers
    loginBtn.onclick = async () => {
      user = await signIn(emailInput.value.trim(), passwordInput.value.trim());
      if (user) {
        loginMessage.textContent = '';
        await afterLogin();
      }
    };

    signUpBtn.onclick = async () => {
      const newUser = await signUp(emailInput.value.trim(), passwordInput.value.trim());
      if (newUser) {
        loginMessage.textContent = 'Signup success. Please check email to confirm.';
      }
    };

    logoutBtn.onclick = async () => {
      await signOut();
    };

    newGameSetBtn.onclick = async () => {
      await createNewGameSet();
    };

    gameSetSelect.onchange = async () => {
      await loadSelectedGameSet();
    };

    generateBtn.onclick = async () => {
      await saveScheduleAndMatches();
    };

    editableToggle.onchange = async () => {
      if (!currentGameSet) return;
      const { error } = await supabase
        .from('game_sets')
        .update({ editable: editableToggle.checked })
        .eq('id', currentGameSet.id);
      if (error) {
        alert('Error updating editable flag: ' + error.message);
        editableToggle.checked = !editableToggle.checked; // revert
      } else {
        currentGameSet.editable = editableToggle.checked;
        renderSchedule();
      }
    };

    exportCsvBtn.onclick = () => {
      exportCsv();
    };

    // Check session on load
    async function afterLogin() {
      user = supabase.auth.getUser().then(r => r.data.user);
      if (!user) {
        showLogin();
        return;
      }
      showApp();
      await loadGameSets();
    }

    // Init: check for active session
    const { data: { session } } = await supabase.auth.getSession();
    if (session && session.user) {
      user = session.user;
      showApp();
      await loadGameSets();
    } else {
      showLogin();
    }
  })();
</script>

