<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Padel Manager - Scheduler & Scoring with Auth</title>
  <style>
    /* Your existing CSS here */
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600&display=swap');
    body {
      margin: 0; padding: 20px;
      background: linear-gradient(135deg, #42291a 0%, #f5d68f 100%);
      font-family: 'Rajdhani', sans-serif;
      color: #2c1b0f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }
    h1 {
      margin-bottom: 5px;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
    }
    label, select, input, button {
      font-size: 1.1rem;
      margin: 5px 0;
      border-radius: 6px;
    }
    select, input[type=text], input[type=number], input[type=email] {
      padding: 8px 10px;
      border: none;
      width: 280px;
      box-sizing: border-box;
      outline: none;
      border: 2px solid #c3a66d;
      background: #fff9e1;
      color: #4d3b1b;
      transition: border-color 0.3s ease;
    }
    select:focus, input[type=text]:focus, input[type=number]:focus, input[type=email]:focus {
      border-color: #8a5a21;
    }
    button {
      background: #8a5a21;
      color: #f2e4c9;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(138, 90, 33, 0.6);
      transition: background-color 0.3s ease;
      user-select: none;
    }
    button:hover {
      background: #6b4413;
    }
    table {
      margin-top: 25px;
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
      background: #f5d68f;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      user-select: text;
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      border-bottom: 1px solid #c3a66d;
      font-weight: 600;
      color: #4d3b1b;
    }
    th {
      background: #8a5a21;
      color: #f2e4c9;
      user-select: none;
    }
    input.score-input {
      width: 48px;
      padding: 6px 4px;
      font-size: 1rem;
      text-align: center;
      border: 2px solid #c3a66d;
      border-radius: 6px;
      background: #fff9e1;
      color: #4d3b1b;
    }
    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #matchList {
      max-height: 300px;
      overflow-y: auto;
    }
    #exportCsvBtn, #saveSupabaseBtn {
      margin-top: 15px;
      background: #6b4413;
      margin-left: 10px;
    }
    #persistenceToggle {
      margin-left: 8px;
      vertical-align: middle;
      transform: scale(1.2);
      cursor: pointer;
    }
    #scoreboard {
      margin-top: 25px;
      max-width: 600px;
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      background: #f5d68f;
      padding: 10px 0;
    }
    #scoreboard table {
      width: 100%;
      border-collapse: collapse;
    }
    /* Auth UI styling */
    #authContainer {
      background: #f5d68f;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      width: 320px;
      text-align: center;
      color: #4d3b1b;
      user-select: text;
    }
    #authStatus {
      margin-top: 8px;
      font-weight: 600;
    }
  </style>
</head>
<body>

<div class="container">

  <h1>Padel Manager (with User Login)</h1>

  <!-- Auth UI -->
  <div id="authContainer">
    <input id="emailInput" type="email" placeholder="Enter your email" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
    <button id="loginBtn">Send Magic Link</button>
    <button id="logoutBtn" style="display:none;">Logout</button>
    <p id="authStatus">Not logged in</p>
  </div>

  <label for="gameSetSelect">Load Saved Schedule:</label>
  <select id="gameSetSelect">
    <option value="">-- Login to see saved schedules --</option>
  </select>

  <label for="playerCount">Select Players (no mid-session switch):</label>
  <select id="playerCount">
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>

  <label for="playerNames">Enter Player Names (comma separated):</label>
  <input id="playerNames" type="text" placeholder="Alice,Bob,Charlie,David,Eva" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

  <label for="rounds">Number of rounds (games):</label>
  <input id="rounds" type="number" min="1" value="15" />

  <button id="generateBtn">Generate Schedule</button>
  <button id="saveSupabaseBtn">Save Schedule & Scores to Supabase</button>

  <label><input type="checkbox" id="persistenceToggle" checked /> Persist scores between reloads</label>

  <div id="scheduleOutput"></div>

  <div id="scoreboard"></div>

  <h2>Match History (editable scores)</h2>
  <div id="matchList"></div>

  <button id="exportCsvBtn">Export Matches CSV</button>
</div>

<script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

  const SUPABASE_URL = 'https://vgcvemwzqyqwlwckoafu.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZnY3ZlbXd6cXlxd2x3Y2tvYWZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDk4NDIsImV4cCI6MjA3MDU4NTg0Mn0.zs5403wZkhPU1JU9AV0FVRUD_WBdf2oDV-eoKHmT-2U';

  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const STORAGE_KEY = "padel_manager_data";

  // UI elements
  const authContainer = document.getElementById('authContainer');
  const emailInput = document.getElementById('emailInput');
  const loginBtn = document.getElementById('loginBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const authStatus = document.getElementById('authStatus');

  const gameSetSelect = document.getElementById('gameSetSelect');
  const playerCountSelect = document.getElementById("playerCount");
  const playerNamesInput = document.getElementById("playerNames");
  const roundsInput = document.getElementById("rounds");
  const generateBtn = document.getElementById("generateBtn");
  const saveSupabaseBtn = document.getElementById("saveSupabaseBtn");
  const scheduleOutput = document.getElementById("scheduleOutput");
  const scoreboardDiv = document.getElementById("scoreboard");
  const matchListDiv = document.getElementById("matchList");
  const exportCsvBtn = document.getElementById("exportCsvBtn");
  const persistenceToggle = document.getElementById("persistenceToggle");

  // App state
  let currentUser = null;
  let players = [];
  let playerCount = 5;
  let rounds = 15;
  let schedule = [];
  let scores = [];
  let playerStats = {};

  // --- Scheduler functions ---

  function scheduleFourPlayers(players, rounds) {
    const combos = [
      [[players[0], players[1]], [players[2], players[3]]],
      [[players[0], players[2]], [players[1], players[3]]],
      [[players[0], players[3]], [players[1], players[2]]]
    ];
    let schedule = [];
    for(let i=0; i < rounds; i++) {
      const c = combos[i % combos.length];
      schedule.push({
        id: i+1,
        team1: c[0],
        team2: c[1],
        rest: []
      });
    }
    return schedule;
  }

  function scheduleFivePlayers(players, rounds) {
    let schedule = [];
    let restingOrder = [...players];
    for(let i=0; i < rounds; i++) {
      let rest = restingOrder[0];
      let active = restingOrder.slice(1);

      let team1, team2;
      if (i % 2 === 0) {
        team1 = [active[0], active[1]];
        team2 = [active[2], active[3]];
      } else {
        team1 = [active[1], active[0]];
        team2 = [active[3], active[2]];
      }

      schedule.push({
        id: i+1,
        team1,
        team2,
        rest: [rest]
      });
      restingOrder.push(restingOrder.shift());
    }
    return schedule;
  }

  function validatePlayerNames(names, count) {
    if (names.length !== count) return false;
    for (const n of names) if (!n) return false;
    return true;
  }

  function resetPlayerStats(players) {
    let stats = {};
    players.forEach(p => {
      stats[p] = { points: 0, games: 0, index: 0 };
    });
    return stats;
  }

  function calculatePlayerStats(schedule, scores) {
    let stats = resetPlayerStats(players);
    scores.forEach(score => {
      let match = schedule.find(m => m.id === score.matchId);
      if (!match) return;
      const t1score = parseInt(score.team1Score, 10) || 0;
      const t2score = parseInt(score.team2Score, 10) || 0;

      match.team1.forEach(p => {
        stats[p].points += t1score;
        stats[p].games++;
      });
      match.team2.forEach(p => {
        stats[p].points += t2score;
        stats[p].games++;
      });
    });

    Object.values(stats).forEach(s => {
      s.index = s.games > 0 ? (s.points / s.games).toFixed(2) : "0.00";
    });
    return stats;
  }

  function renderSchedule(schedule, playerCount) {
    if (!schedule.length) {
      scheduleOutput.innerHTML = "<p>No schedule generated yet.</p>";
      return;
    }

    let html = `<table><thead><tr>
      <th>Match #</th>
      ${playerCount === 5 ? "<th>Resting</th>" : ""}
      <th>Team 1</th><th>Team 2</th><th>Score Team 1</th><th>Score Team 2</th>
    </tr></thead><tbody>`;

    schedule.forEach(match => {
      const restStr = playerCount === 5 ? `<td>${match.rest[0]}</td>` : "";
      const scoreObj = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };

      html += `<tr data-matchid="${match.id}">
        <td>${match.id}</td>
        ${restStr}
        <td>${match.team1.join(" & ")}</td>
        <td>${match.team2.join(" & ")}</td>
        <td><input class="score-input" type="number" min="0" max="3" pattern="[0-3]" inputmode="numeric" maxlength="1" value="${scoreObj.team1Score}" data-team="1" data-match="${match.id}" /></td>
        <td><input class="score-input" type="number" min="0" max="3" pattern="[0-3]" inputmode="numeric" maxlength="1" value="${scoreObj.team2Score}" data-team="2" data-match="${match.id}" /></td>
      </tr>`;
    });
    html += "</tbody></table>";
    scheduleOutput.innerHTML = html;

    document.querySelectorAll(".score-input").forEach(input => {
      input.addEventListener("input", e => {
        const matchId = parseInt(e.target.dataset.match, 10);
        const teamNum = e.target.dataset.team;
        let scoreEntry = scores.find(s => s.matchId === matchId);
        if (!scoreEntry) {
          scoreEntry = { matchId, team1Score: "", team2Score: "" };
          scores.push(scoreEntry);
        }
        if (teamNum === "1") scoreEntry.team1Score = e.target.value;
        else scoreEntry.team2Score = e.target.value;
        updateAfterScoreChange();
      });
    });
  }

  function renderScoreboard(stats) {
    let html = `<table><thead><tr>
      <th>Player</th><th>Points</th><th>Games Played</th><th>Points/Game Index</th>
    </tr></thead><tbody>`;

    Object.entries(stats).forEach(([player, stat]) => {
      html += `<tr>
        <td>${player}</td>
        <td>${stat.points}</td>
        <td>${stat.games}</td>
        <td>${stat.index}</td>
      </tr>`;
    });
    html += "</tbody></table>";
    scoreboardDiv.innerHTML = html;
  }

  function renderMatchHistory(schedule) {
    if (!schedule.length) {
      matchListDiv.innerHTML = "<p>No matches yet.</p>";
      return;
    }

    let html = `<table><thead><tr>
      <th>Match ID</th>
      <th>Date/Time</th>
      <th>Team 1</th><th>Team 1 Score</th>
      <th>Team 2</th><th>Team 2 Score</th>
      ${playerCount === 5 ? "<th>Resting</th>" : ""}
    </tr></thead><tbody>`;

    schedule.forEach(match => {
      const scoreEntry = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };
      const dt = new Date().toLocaleString();

      html += `<tr>
        <td>${match.id}</td>
        <td>${dt}</td>
        <td>${match.team1.join(" & ")}</td>
        <td>${scoreEntry.team1Score || ""}</td>
        <td>${match.team2.join(" & ")}</td>
        <td>${scoreEntry.team2Score || ""}</td>
        ${playerCount === 5 ? `<td>${match.rest[0]}</td>` : ""}
      </tr>`;
    });

    html += "</tbody></table>";
    matchListDiv.innerHTML = html;
  }

  function updateAfterScoreChange() {
    playerStats = calculatePlayerStats(schedule, scores);
    renderScoreboard(playerStats);
    renderMatchHistory(schedule);
    if (persistenceToggle.checked) saveData();
  }

  function saveData() {
    try {
      const data = {
        players,
        playerCount,
        rounds,
        schedule,
        scores
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch (e) {
      console.warn("Failed to save data:", e);
    }
  }

  function loadLocalData() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      if (!data || !data.players || !data.schedule) return false;
      players = data.players;
      playerCount = data.playerCount || 5;
      rounds = data.rounds || 15;
      schedule = data.schedule;
      scores = data.scores || [];
      playerCountSelect.value = playerCount;
      playerNamesInput.value = players.join(",");
      roundsInput.value = rounds;
      renderSchedule(schedule, playerCount);
      updateAfterScoreChange();
      return true;
    } catch (e) {
      console.warn("Failed to load local data:", e);
      return false;
    }
  }

  // --- Supabase Authentication ---

  loginBtn.addEventListener('click', async () => {
    const email = emailInput.value.trim();
    if (!email) {
      alert("Please enter your email");
      return;
    }
    const { error } = await supabase.auth.signInWithOtp({ email, options: { redirectTo: 'https://yourdomain.com' } });
    if (error) {
      alert("Failed to send magic link: " + error.message);
    } else {
      authStatus.textContent = "Magic link sent to your email. Please check.";
    }
  });

  logoutBtn.addEventListener('click', async () => {
    await supabase.auth.signOut();
  });

  supabase.auth.onAuthStateChange((event, session) => {
    currentUser = session?.user ?? null;
    updateAuthUI();
    if (currentUser) {
      loadGameSetsForUser(currentUser.id);
    } else {
      clearGameSets();
    }
  });

  function updateAuthUI() {
    if (currentUser) {
      authStatus.textContent = `Logged in as: ${currentUser.email}`;
      loginBtn.style.display = "none";
      logoutBtn.style.display = "inline-block";
      emailInput.style.display = "none";
      saveSupabaseBtn.disabled = false;
      generateBtn.disabled = false;
    } else {
      authStatus.textContent = "Not logged in";
      loginBtn.style.display = "inline-block";
      logoutBtn.style.display = "none";
      emailInput.style.display = "inline-block";
      saveSupabaseBtn.disabled = true;
      generateBtn.disabled = false;
      gameSetSelect.innerHTML = '<option value="">-- Login to see saved schedules --</option>';
    }
  }

  // --- Supabase Save & Load ---

  async function loadGameSetsForUser(userId) {
    try {
      const { data, error } = await supabase
        .from('game_sets')
        .select('id, created_at, player_count, players, rounds')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

      if (error) {
        alert('Error loading schedules: ' + error.message);
        return;
      }

      if (!data.length) {
        gameSetSelect.innerHTML = '<option value="">-- No saved schedules found --</option>';
        return;
      }

      gameSetSelect.innerHTML = '<option value="">-- Select a saved schedule --</option>';
      data.forEach(gs => {
        const playersStr = gs.players.join(", ");
        const optionText = `${new Date(gs.created_at).toLocaleString()} | Players: ${gs.player_count} | ${playersStr}`;
        const option = document.createElement("option");
        option.value = gs.id;
        option.textContent = optionText;
        gameSetSelect.appendChild(option);
      });
    } catch (e) {
      alert("Unexpected error loading schedules");
    }
  }

  function clearGameSets() {
    gameSetSelect.innerHTML = '<option value="">-- Login to see saved schedules --</option>';
  }

  gameSetSelect.addEventListener("change", async (e) => {
    const id = e.target.value;
    if (!id) return;

    const { data, error } = await supabase
      .from('game_sets')
      .select('*')
      .eq('id', id)
      .eq('user_id', currentUser.id)
      .single();

    if (error) {
      alert("Failed to load schedule: " + error.message);
      return;
    }

    players = data.players;
    playerCount = data.player_count;
    rounds = data.rounds;

    playerCountSelect.value = playerCount;
    playerNamesInput.value = players.join(",");
    roundsInput.value = rounds;

    // Load associated games & scores
    const { data: gamesData, error: gamesError } = await supabase
      .from('padel_games')
      .select('*')
      .eq('game_set_id', id)
      .eq('user_id', currentUser.id)
      .order('id');

    if (gamesError) {
      alert("Failed to load games: " + gamesError.message);
      return;
    }

    schedule = [];
    scores = [];

    gamesData.forEach(g => {
      schedule.push({
        id: g.match_id,
        team1: [g.team1_player1, g.team1_player2],
        team2: [g.team2_player1, g.team2_player2],
        rest: g.resting_player ? [g.resting_player] : []
      });
      scores.push({
        matchId: g.match_id,
        team1Score: g.team1_score,
        team2Score: g.team2_score
      });
    });

    renderSchedule(schedule, playerCount);
    updateAfterScoreChange();
  });

  saveSupabaseBtn.addEventListener("click", async () => {
    if (!currentUser) {
      alert("You must be logged in to save schedules.");
      return;
    }

    if (!schedule.length) {
      alert("No schedule to save. Generate one first.");
      return;
    }

    try {
      // Insert or update game_sets row
      const { data: insertData, error: insertError } = await supabase
        .from('game_sets')
        .insert([{
          player_count: playerCount,
          players: players,
          rounds: rounds,
          user_id: currentUser.id
        }])
        .select()
        .single();

      if (insertError) {
        alert("Error saving schedule: " + insertError.message);
        return;
      }

      const gameSetId = insertData.id;

      // Remove any existing padel_games for this game_set_id and user
      await supabase
        .from('padel_games')
        .delete()
        .eq('game_set_id', gameSetId)
        .eq('user_id', currentUser.id);

      // Insert padel_games with scores
      const gamesToInsert = schedule.map(match => {
        const score = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };
        return {
          game_set_id: gameSetId,
          user_id: currentUser.id,
          match_id: match.id,
          team1_player1: match.team1[0],
          team1_player2: match.team1[1],
          team2_player1: match.team2[0],
          team2_player2: match.team2[1],
          resting_player: (playerCount === 5) ? (match.rest[0] || null) : null,
          team1_score: score.team1Score || null,
          team2_score: score.team2Score || null,
        };
      });

      const { error: gamesInsertError } = await supabase
        .from('padel_games')
        .insert(gamesToInsert);

      if (gamesInsertError) {
        alert("Error saving games: " + gamesInsertError.message);
        return;
      }

      alert("Schedule and scores saved successfully!");
      // Refresh saved schedules list
      loadGameSetsForUser(currentUser.id);

    } catch (e) {
      alert("Unexpected error saving schedule.");
    }
  });

  // --- Generate & Save local data ---

  generateBtn.addEventListener("click", () => {
    playerCount = parseInt(playerCountSelect.value, 10);
    players = playerNamesInput.value.split(",").map(p => p.trim()).filter(Boolean);
    rounds = parseInt(roundsInput.value, 10);

    if (!validatePlayerNames(players, playerCount)) {
      alert(`Please enter exactly ${playerCount} player names, comma separated.`);
      return;
    }

    if (rounds < 1) {
      alert("Rounds must be at least 1");
      return;
    }

    schedule = playerCount === 4
      ? scheduleFourPlayers(players, rounds)
      : scheduleFivePlayers(players, rounds);

    scores = [];
    renderSchedule(schedule, playerCount);
    updateAfterScoreChange();
    if (persistenceToggle.checked) saveData();
  });

  exportCsvBtn.addEventListener("click", () => {
    if (!schedule.length) {
      alert("No schedule to export.");
      return;
    }
    let csv = "Match ID,Resting,Team 1,Team 1 Score,Team 2,Team 2 Score\n";
    schedule.forEach(match => {
      const score = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };
      csv += `${match.id},${playerCount === 5 ? match.rest[0] : ""},` +
        `"${match.team1.join(" & ")}",${score.team1Score || ""},` +
        `"${match.team2.join(" & ")}",${score.team2Score || ""}\n`;
    });
    const blob = new Blob([csv], {type: "text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "padel_schedule.csv";
    a.click();
    URL.revokeObjectURL(url);
  });

  // Load local data on page load if persistence is enabled
  window.addEventListener("load", () => {
    if (persistenceToggle.checked) {
      loadLocalData();
    }
  });

  persistenceToggle.addEventListener("change", () => {
    if (!persistenceToggle.checked) {
      localStorage.removeItem(STORAGE_KEY);
    } else {
      saveData();
    }
  });

</script>

</body>
</html>

