<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Padel Game Manager</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
  body {
    margin: 0; padding: 0;
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, #dba458, #70421f);
    color: #fff;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    text-align: center;
    margin: 1rem 0 0.5rem 0;
    font-weight: 700;
    font-size: 1.8rem;
    text-shadow: 0 0 6px #b87532;
  }
  main {
    width: 95vw;
    max-width: 900px;
    background: rgba(30,15,5,0.75);
    border-radius: 12px;
    box-shadow: 0 0 15px #b8741d;
    padding: 15px 20px 30px 20px;
    margin-bottom: 40px;
  }
  label {
    display: block;
    margin-top: 10px;
    font-weight: 600;
  }
  select, input[type=text] {
    padding: 6px 8px;
    border-radius: 6px;
    border: none;
    font-size: 1rem;
    margin-top: 4px;
    width: 100%;
    max-width: 280px;
  }
  button {
    margin-top: 12px;
    background: linear-gradient(45deg, #e6ba4b, #a9691b);
    border: none;
    color: #fff;
    font-weight: 700;
    padding: 10px 18px;
    font-size: 1.1rem;
    border-radius: 30px;
    cursor: pointer;
    box-shadow: 0 0 12px #e6ba4b;
    display: inline-flex;
    align-items: center;
  }
  button:hover {
    background: linear-gradient(45deg, #f0ca66, #c37f29);
    box-shadow: 0 0 18px #f0ca66;
  }
  button svg {
    width: 20px; height: 20px; margin-right: 8px;
    fill: #fff;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 14px;
    font-size: 0.9rem;
  }
  thead {
    background: rgba(184, 135, 37, 0.9);
    font-weight: 700;
  }
  th, td {
    padding: 6px 8px;
    text-align: center;
    border: 1px solid #b87f16;
    vertical-align: middle;
  }
  tbody tr:nth-child(odd) {
    background: rgba(255 255 255 / 0.05);
  }
  input.score-input {
    width: 40px;
    text-align: center;
    font-weight: 600;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    background: rgba(255 255 255 / 0.15);
    color: #fff;
  }
  input.score-input:focus {
    outline: 2px solid #e6ba4b;
    background: rgba(255 255 255 / 0.3);
  }
  .flex-row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: flex-end;
    margin-top: 8px;
  }
  .player-input {
    flex: 1 1 140px;
  }
  .score-entry {
    margin-top: 14px;
    padding-top: 12px;
    border-top: 1px solid #b87f16;
  }
  .leaderboard-container, .match-history-container, .score-entry-container {
    margin-top: 20px;
  }
  .toggle-persist {
    margin-top: 14px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }
  .reset-btn {
    margin-top: 16px;
    background: #b85418;
    box-shadow: 0 0 14px #b85418;
  }
  .reset-btn:hover {
    background: #e6701e;
    box-shadow: 0 0 18px #e6701e;
  }
  footer {
    margin-top: auto;
    padding: 12px;
    font-size: 0.9rem;
    color: #b8974f;
    text-align: center;
  }
  /* Scroll horizontal for tables on small */
  .scroll-table {
    overflow-x: auto;
  }
  /* Responsive */
  @media (max-width: 520px) {
    .flex-row {
      flex-direction: column;
      align-items: stretch;
    }
    input.score-input {
      width: 100%;
      max-width: 100%;
    }
  }
</style>
</head>
<body>
<header>Padel Game Manager</header>
<main>

<div id="setup-screen">
  <label for="player-count">Number of players:</label>
  <select id="player-count">
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>
  <div id="player-names-inputs" style="margin-top:10px;">
    <!-- Dynamic inputs for player names -->
  </div>
  <button id="start-session-btn">Start Session</button>
</div>

<div id="app-screen" style="display:none;">
  
  <section class="score-entry-container">
    <h2>Enter Game Scores</h2>
    <div id="current-match-number" style="font-weight:700; margin-bottom:8px;"></div>
    <div id="score-entry-fields" class="flex-row">
      <!-- Dynamic score inputs -->
    </div>
    <button id="save-score-btn">Save Score</button>
    <label class="toggle-persist">
      <input type="checkbox" id="persist-scores" checked /> Persist scores (local storage)
    </label>
    <button id="reset-session-btn" class="reset-btn">Reset Session</button>
  </section>

  <section class="leaderboard-container">
    <h2>Leaderboard</h2>
    <div class="scroll-table">
      <table id="leaderboard-table">
        <thead>
          <tr>
            <th>Player</th>
            <th>Points</th>
            <th>Games Played</th>
            <th>Points/Game</th>
          </tr>
        </thead>
        <tbody>
          <!-- Dynamic leaderboard rows -->
        </tbody>
      </table>
    </div>
  </section>

  <section class="match-history-container">
    <h2>Match History</h2>
    <button id="export-csv-btn" title="Export match history as CSV">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-18L5.33 9h3.67v6h4v-6h3.67L12 2z"/></svg>
      Download CSV
    </button>
    <div class="scroll-table" style="margin-top: 10px;">
      <table id="match-history-table">
        <thead>
          <tr>
            <th>Match #</th>
            <th>Date/Time</th>
            <th>Double 1 Player A</th>
            <th>Double 1 Player B</th>
            <th>Double 2 Player A</th>
            <th>Double 2 Player B</th>
            <th>Score Double 1</th>
            <th>Score Double 2</th>
            <th>Points Player A</th>
            <th>Points Player B</th>
            <th>Points Player C</th>
            <th>Points Player D</th>
            <th>Player Out</th>
          </tr>
        </thead>
        <tbody>
          <!-- Dynamic match history rows -->
        </tbody>
      </table>
    </div>
  </section>

</div>

</main>
<footer>Padel Manager © 2025 — Powered by Your Desert Padel</footer>

<script>
(() => {
  // State
  let players = [];
  let numPlayers = 5;
  let matches = [];
  let currentMatchIndex = 0;
  let persistScores = true;

  const setupScreen = document.getElementById('setup-screen');
  const appScreen = document.getElementById('app-screen');
  const playerCountSelect = document.getElementById('player-count');
  const playerNamesInputsDiv = document.getElementById('player-names-inputs');
  const startSessionBtn = document.getElementById('start-session-btn');

  const currentMatchNumberDiv = document.getElementById('current-match-number');
  const scoreEntryFieldsDiv = document.getElementById('score-entry-fields');
  const saveScoreBtn = document.getElementById('save-score-btn');
  const persistCheckbox = document.getElementById('persist-scores');
  const resetSessionBtn = document.getElementById('reset-session-btn');

  const leaderboardTableBody = document.querySelector('#leaderboard-table tbody');
  const matchHistoryTableBody = document.querySelector('#match-history-table tbody');
  const exportCsvBtn = document.getElementById('export-csv-btn');

  // Initialize player name inputs on setup screen
  function renderPlayerNameInputs() {
    playerNamesInputsDiv.innerHTML = '';
    const count = parseInt(playerCountSelect.value);
    for(let i=0; i < count; i++) {
      const label = document.createElement('label');
      label.textContent = `Player ${i+1} Name:`;
      label.setAttribute('for', `player-name-${i}`);
      const input = document.createElement('input');
      input.type = 'text';
      input.id = `player-name-${i}`;
      input.value = `Player${i+1}`;
      input.required = true;
      input.classList.add('player-input');
      playerNamesInputsDiv.appendChild(label);
      playerNamesInputsDiv.appendChild(input);
    }
  }

  playerCountSelect.addEventListener('change', () => {
    renderPlayerNameInputs();
  });

  // Utility shuffle function
  function shuffleArray(arr) {
    const a = arr.slice();
    for(let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Improved 5-player schedule generator with backtracking to avoid consecutive doubles repeats
  function generateMatchesFive(players) {
    let doubles = [];
    for(let i=0; i<players.length; i++) {
      for(let j=i+1; j<players.length; j++) {
        doubles.push([players[i], players[j]]);
      }
    }
    let candidateMatches = [];
    for(let i=0; i<doubles.length; i++) {
      for(let j=i+1; j<doubles.length; j++) {
        const d1 = doubles[i];
        const d2 = doubles[j];
        const allPlayers = [...d1, ...d2];
        const uniquePlayers = new Set(allPlayers);
        if(uniquePlayers.size === 4) {
          const outPlayer = players.find(p => !uniquePlayers.has(p));
          candidateMatches.push({double1: d1, double2: d2, playerOut: outPlayer});
        }
      }
    }

    function sameDoubles(m1, m2) {
      const setsEqual = (a,b) => a.length === b.length && a.every(v => b.includes(v));
      return (setsEqual(m1.double1, m2.double1) && setsEqual(m1.double2, m2.double2)) ||
             (setsEqual(m1.double1, m2.double2) && setsEqual(m1.double2, m2.double1));
    }

    let schedule = [];
    const usedIndices = new Set();
    const TARGET = 15;
    function expectedOutPlayerAtIndex(idx) {
      return candidateMatches[Math.floor(idx / 4) * 4].playerOut;
    }

    function backtrack(idx) {
      if(idx === TARGET) return true;
      for(let i=0; i < candidateMatches.length; i++) {
        if(usedIndices.has(i)) continue;
        const candidate = candidateMatches[i];
        if(candidate.playerOut !== expectedOutPlayerAtIndex(idx)) continue;
        if(idx > 0 && sameDoubles(schedule[idx - 1], candidate)) continue;
        schedule.push(candidate);
        usedIndices.add(i);
        if(backtrack(idx + 1)) return true;
        schedule.pop();
        usedIndices.delete(i);
      }
      return false;
    }

    const success = backtrack(0);

    if(!success) {
      schedule = candidateMatches.slice(0, TARGET);
    }

    return schedule.map((m, idx) => ({
      id: idx+1,
      datetime: new Date().toISOString(),
      double1: m.double1,
      double2: m.double2,
      playerOut: m.playerOut,
      scoreD1: null,
      scoreD2: null,
      pointsPerPlayer: {}
    }));
  }

  // 4-player matches generator (unchanged)
  function generateMatchesFour(players) {
    let doubles = [];
    for(let i=0; i<players.length; i++) {
      for(let j=i+1; j<players.length; j++) {
        doubles.push([players[i], players[j]]);
      }
    }
    const possibleMatches = [
      {double1: doubles[0], double2: doubles[5]},
      {double1: doubles[1], double2: doubles[4]},
      {double1: doubles[2], double2: doubles[3]}
    ];
    let schedule = [];
    for(let i=0; i<15; i++) {
      const match = possibleMatches[i % possibleMatches.length];
      schedule.push({
        id: i+1,
        datetime: new Date().toISOString(),
        double1: match.double1,
        double2: match.double2,
        playerOut: null,
        scoreD1: null,
        scoreD2: null,
        pointsPerPlayer: {}
      });
    }
    return schedule;
  }

  function calculateLeaderboard() {
    let stats = {};
    players.forEach(p => stats[p] = {points:0, gamesPlayed:0});
    matches.forEach(match => {
      if(match.scoreD1 === null || match.scoreD2 === null) return;
      match.double1.forEach(p => {
        stats[p].points += match.scoreD1;
        stats[p].gamesPlayed++;
      });
      match.double2.forEach(p => {
        stats[p].points += match.scoreD2;
        stats[p].gamesPlayed++;
      });
    });
    Object.keys(stats).forEach(p => {
      let sp = stats[p];
      sp.index = sp.gamesPlayed ? (sp.points / sp.gamesPlayed) : 0;
    });
    return stats;
  }

  function renderLeaderboard() {
    const stats = calculateLeaderboard();
    const sorted = Object.entries(stats).sort((a,b) => {
      if(b[1].points !== a[1].points) return b[1].points - a[1].points;
      return b[1].index - a[1].index;
    });
    leaderboardTableBody.innerHTML = '';
    sorted.forEach(([p, s]) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${p}</td>
        <td>${s.points}</td>
        <td>${s.gamesPlayed}</td>
        <td>${s.index.toFixed(2)}</td>
      `;
      leaderboardTableBody.appendChild(tr);
    });
  }

  function renderMatchHistory() {
    matchHistoryTableBody.innerHTML = '';
    matches.forEach(match => {
      const tr = document.createElement('tr');
      const ptsCells = players.map(p => {
        const val = match.pointsPerPlayer[p];
        return `<td>${val != null ? val : ''}</td>`;
      }).join('');
      tr.innerHTML = `
        <td>${match.id}</td>
        <td>${new Date(match.datetime).toLocaleString()}</td>
        <td>${match.double1[0]}</td>
        <td>${match.double1[1]}</td>
        <td>${match.double2[0]}</td>
        <td>${match.double2[1]}</td>
        <td>${match.scoreD1 != null ? match.scoreD1 : ''}</td>
        <td>${match.scoreD2 != null ? match.scoreD2 : ''}</td>
        ${ptsCells}
        <td>${match.playerOut || ''}</td>
      `;
      matchHistoryTableBody.appendChild(tr);
    });
  }

  function renderScoreEntry() {
    if(currentMatchIndex >= matches.length) {
      scoreEntryFieldsDiv.innerHTML = '<em>All matches completed.</em>';
      currentMatchNumberDiv.textContent = '';
      saveScoreBtn.disabled = true;
      return;
    }
    const match = matches[currentMatchIndex];
    currentMatchNumberDiv.textContent = `Match #${match.id} - ${match.double1.join(' & ')} vs ${match.double2.join(' & ')}`;
    saveScoreBtn.disabled = false;
    scoreEntryFieldsDiv.innerHTML = '';

    const createScoreInput = (labelText, initialValue, id) => {
      const div = document.createElement('div');
      div.style.textAlign = 'center';
      const label = document.createElement('label');
      label.textContent = labelText;
      label.setAttribute('for', id);
      label.style.fontWeight = '600';
      label.style.display = 'block';
      label.style.marginBottom = '4px';
      const input = document.createElement('input');
      input.type = 'number';
      input.min = 0;
      input.max = 3;
      input.id = id;
      input.className = 'score-input';
      input.value = initialValue != null ? initialValue : '';
      input.setAttribute('inputmode', 'numeric');
      input.required = true;
      div.appendChild(label);
      div.appendChild(input);
      return div;
    };

    scoreEntryFieldsDiv.appendChild(createScoreInput(`Score for ${match.double1.join(' & ')}`, match.scoreD1, 'scoreD1'));
    scoreEntryFieldsDiv.appendChild(createScoreInput(`Score for ${match.double2.join(' & ')}`, match.scoreD2, 'scoreD2'));
  }

  function calcPointsPerPlayer(match) {
    if(match.scoreD1 == null || match.scoreD2 == null) {
      match.pointsPerPlayer = {};
      return;
    }
    const pts = {};
    match.double1.forEach(p => pts[p] = match.scoreD1);
    match.double2.forEach(p => pts[p] = match.scoreD2);
    if(match.playerOut) pts[match.playerOut] = null;
    match.pointsPerPlayer = pts;
  }

  function saveScore() {
    if(currentMatchIndex >= matches.length) return;
    const s1 = parseInt(document.getElementById('scoreD1').value);
    const s2 = parseInt(document.getElementById('scoreD2').value);
    if(isNaN(s1) || isNaN(s2)) {
      alert('Please enter numeric scores for both doubles.');
      return;
    }
    if(s1 < 0 || s2 < 0 || s1 > 3 || s2 > 3) {
      alert('Scores must be between 0 and 3.');
      return;
    }
    matches[currentMatchIndex].scoreD1 = s1;
    matches[currentMatchIndex].scoreD2 = s2;
    calcPointsPerPlayer(matches[currentMatchIndex]);
    currentMatchIndex++;
    persistData();
    renderScoreEntry();
    renderLeaderboard();
    renderMatchHistory();
  }

  function persistData() {
    if(!persistScores) return;
    const data = {
      players,
      numPlayers,
      matches,
      currentMatchIndex
    };
    localStorage.setItem('padelManagerData', JSON.stringify(data));
  }

  function loadData() {
    const dataRaw = localStorage.getItem('padelManagerData');
    if(!dataRaw) return false;
    try {
      const data = JSON.parse(dataRaw);
      if(!data.players || !data.matches) return false;
      players = data.players;
      numPlayers = data.numPlayers;
      matches = data.matches;
      currentMatchIndex = data.currentMatchIndex || 0;
      return true;
    } catch {
      return false;
    }
  }

  function resetSession() {
    if(confirm('Reset session? All data will be lost.')) {
      localStorage.removeItem('padelManagerData');
      location.reload();
    }
  }

  function exportCSV() {
    if(matches.length === 0) {
      alert('No matches to export.');
      return;
    }
    const header = [
      'Match #',
      'Date/Time',
      'Double 1 Player A',
      'Double 1 Player B',
      'Double 2 Player A',
      'Double 2 Player B',
      'Score Double 1',
      'Score Double 2',
      ...players,
      numPlayers === 5 ? 'Player Out' : ''
    ].filter(Boolean);

    const rows = matches.map(m => {
      const base = [
        m.id,
        new Date(m.datetime).toLocaleString(),
        m.double1[0],
        m.double1[1],
        m.double2[0],
        m.double2[1],
        m.scoreD1 != null ? m.scoreD1 : '',
        m.scoreD2 != null ? m.scoreD2 : ''
      ];
      const pts = players.map(p => {
        const val = m.pointsPerPlayer ? m.pointsPerPlayer[p] : null;
        return val != null ? val : '';
      });
      const outP = numPlayers === 5 ? (m.playerOut || '') : '';
      return [...base, ...pts, outP];
    });

    function escapeCSV(val) {
      if(val == null) return '';
      val = val.toString();
      if(val.includes(',') || val.includes('"') || val.includes('\n')) {
        return `"${val.replace(/"/g, '""')}"`;
      }
      return val;
    }

    const csvContent = [header, ...rows].map(row => row.map(escapeCSV).join(',')).join('\n');

    const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth()+1).padStart(2,'0');
    const dd = String(today.getDate()).padStart(2,'0');
    a.download = `padel_history_${yyyy}-${mm}-${dd}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  startSessionBtn.addEventListener('click', () => {
    const inputs = playerNamesInputsDiv.querySelectorAll('input[type=text]');
    const names = [];
    for(let input of inputs) {
      const val = input.value.trim();
      if(!val) {
        alert('Please enter all player names.');
        return;
      }
      names.push(val);
    }
    players = names;
    numPlayers = players.length;
    if(numPlayers === 5) {
      matches = generateMatchesFive(players);
    } else if(numPlayers === 4) {
      matches = generateMatchesFour(players);
    } else {
      alert('Only 4 or 5 players supported.');
      return;
    }
    currentMatchIndex = 0;
    persistScores = persistCheckbox.checked;
    setupScreen.style.display = 'none';
    appScreen.style.display = 'block';
    renderLeaderboard();
    renderMatchHistory();
    renderScoreEntry();
  });

  saveScoreBtn.addEventListener('click', () => {
    saveScore();
  });

  persistCheckbox.addEventListener('change', (e) => {
    persistScores = e.target.checked;
    if(!persistScores) {
      localStorage.removeItem('padelManagerData');
    } else {
      persistData();
    }
  });

  resetSessionBtn.addEventListener('click', () => {
    resetSession();
  });

  exportCsvBtn.addEventListener('click', () => {
    exportCSV();
  });

  window.addEventListener('load', () => {
    if(loadData()) {
      setupScreen.style.display = 'none';
      appScreen.style.display = 'block';
      renderLeaderboard();
      renderMatchHistory();
      renderScoreEntry();
    } else {
      renderPlayerNameInputs();
    }
  });

  renderPlayerNameInputs();

})();
</script>
</body>
</html>