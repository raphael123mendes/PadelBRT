<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Padel Manager - Scheduler & Scoring</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600&display=swap');
    body {
      margin: 0; padding: 20px;
      background: linear-gradient(135deg, #42291a 0%, #f5d68f 100%);
      font-family: 'Rajdhani', sans-serif;
      color: #2c1b0f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }
    h1 {
      margin-bottom: 5px;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
    }
    label, select, input, button {
      font-size: 1.1rem;
      margin: 5px 0;
      border-radius: 6px;
    }
    select, input[type=text], input[type=number] {
      padding: 8px 10px;
      border: none;
      width: 280px;
      box-sizing: border-box;
      outline: none;
      border: 2px solid #c3a66d;
      background: #fff9e1;
      color: #4d3b1b;
      transition: border-color 0.3s ease;
    }
    select:focus, input[type=text]:focus, input[type=number]:focus {
      border-color: #8a5a21;
    }
    button {
      background: #8a5a21;
      color: #f2e4c9;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(138, 90, 33, 0.6);
      transition: background-color 0.3s ease;
      user-select: none;
    }
    button:hover {
      background: #6b4413;
    }
    table {
      margin-top: 25px;
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
      background: #f5d68f;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      user-select: text;
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      border-bottom: 1px solid #c3a66d;
      font-weight: 600;
      color: #4d3b1b;
    }
    th {
      background: #8a5a21;
      color: #f2e4c9;
      user-select: none;
    }
    input.score-input {
      width: 48px;
      padding: 6px 4px;
      font-size: 1rem;
      text-align: center;
      border: 2px solid #c3a66d;
      border-radius: 6px;
      background: #fff9e1;
      color: #4d3b1b;
    }
    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #matchList {
      max-height: 300px;
      overflow-y: auto;
    }
    #exportCsvBtn {
      margin-top: 15px;
      background: #6b4413;
    }
    #persistenceToggle {
      margin-left: 8px;
      vertical-align: middle;
      transform: scale(1.2);
      cursor: pointer;
      display: none; /* Hide, we won't use localStorage persistence */
    }
    #scoreboard {
      margin-top: 25px;
      max-width: 600px;
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      background: #f5d68f;
      padding: 10px 0;
    }
    #scoreboard table {
      width: 100%;
      border-collapse: collapse;
    }

    /* Auth UI */
    #authContainer {
      display: flex;
      flex-direction: column;
      max-width: 320px;
      width: 100%;
      margin-bottom: 20px;
    }
    #authContainer input {
      margin-bottom: 10px;
      font-size: 1rem;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #c3a66d;
      outline: none;
    }
    #authContainer button {
      margin-bottom: 10px;
    }
    #authMessage {
      min-height: 1.2em;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
      font-weight: 600;
      text-align: center;
    }

    /* small admin controls row */
    #controlsRow { display:flex; gap:12px; align-items:center; margin:8px 0; }
  </style>
</head>
<body>

<div id="authContainer">
  <input id="emailInput" type="email" placeholder="Email" />
  <input id="passwordInput" type="password" placeholder="Password" />
  <button id="loginBtn">Login</button>
  <button id="signupBtn">Sign Up</button>
  <p id="authMessage"></p>
</div>

<div id="mainContainer" class="container" style="display:none;">
  <h1>Padel Manager</h1>

  <div id="controlsRow">
    <label for="gameSetSelect">Select Game Set (by date):</label>
    <select id="gameSetSelect"></select>
    <button id="newSetBtn">New Set for Today</button>
    <!-- editable checkbox will be inserted by script -->
  </div>

  <label for="playerCount">Select Players (no mid-session switch):</label>
  <select id="playerCount" disabled>
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>

  <label for="playerNames">Enter Player Names (comma separated):</label>
  <input id="playerNames" type="text" placeholder="Alice,Bob,Charlie,David,Eva" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled>

  <label for="rounds">Number of rounds (games):</label>
  <input id="rounds" type="number" min="1" value="15" disabled />

  <button id="generateBtn" disabled>Generate Schedule</button>

  <div id="scheduleOutput"></div>

  <div id="scoreboard"></div>

  <h2>Match History (editable scores)</h2>
  <div id="matchList"></div>

  <button id="exportCsvBtn">Export Matches CSV</button>
</div>

<!-- Use module import to avoid global naming conflicts and allow modern API -->
<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

  (async () => {
    // ---------- CONFIG ----------
    const supabaseUrl = 'https://vgcvemwzqyqwlwckoafu.supabase.co';
    const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZnY3ZlbXd6cXlxd2x3Y2tvYWZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDk4NDIsImV4cCI6MjA3MDU4NTg0Mn0.zs5403wZkhPU1JU9AV0FVRUD_WBdf2oDV-eoKHmT-2U'; // <-- replace with your anon key
    const sb = createClient(supabaseUrl, supabaseAnonKey);

    // ---------- ELEMENTS (mapped to your original HTML IDs) ----------
    const authContainer = document.getElementById('authContainer');
    const emailInput = document.getElementById('emailInput');
    const passwordInput = document.getElementById('passwordInput');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn');
    const authMessage = document.getElementById('authMessage');

    const mainContainer = document.getElementById('mainContainer');
    const gameSetSelect = document.getElementById('gameSetSelect');
    const newSetBtn = document.getElementById('newSetBtn');
    const playerCountSelect = document.getElementById('playerCount');
    const playerNamesInput = document.getElementById('playerNames');
    const roundsInput = document.getElementById('rounds');
    const generateBtn = document.getElementById('generateBtn');
    const scheduleOutput = document.getElementById('scheduleOutput');
    const scoreboardDiv = document.getElementById('scoreboard');
    const matchListDiv = document.getElementById('matchList');
    const exportCsvBtn = document.getElementById('exportCsvBtn');

    // create and insert editable toggle (so admin can flip editable)
    const controlsRow = document.getElementById('controlsRow');
    const editableLabel = document.createElement('label');
    editableLabel.style.display = 'flex';
    editableLabel.style.alignItems = 'center';
    editableLabel.style.gap = '6px';
    editableLabel.innerHTML = `<input type="checkbox" id="editableToggle" /> Allow editing`;
    controlsRow.appendChild(editableLabel);
    const editableToggle = document.getElementById('editableToggle');

    // ---------- STATE ----------
    let user = null;
    let gameSets = [];
    let currentGameSet = null; // {id, date, editable, player_count, rounds, player_names_json}
    let schedule = [];
    let scores = []; // { match_number, team1_score, team2_score }
    let players = [];
    let playerCount = 5;
    let rounds = 15;
    let playerStats = {};

    // ---------- HELPERS ----------
    function formatDate(d) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }

    // keep your original schedulers
    function scheduleFourPlayers(players, rounds) {
      const combos = [
        [[players[0], players[1]], [players[2], players[3]]],
        [[players[0], players[2]], [players[1], players[3]]],
        [[players[0], players[3]], [players[1], players[2]]]
      ];
      let sched = [];
      for (let i=0;i<rounds;i++){
        const c = combos[i % combos.length];
        sched.push({ id: i+1, team1: c[0], team2: c[1], rest: [] });
      }
      return sched;
    }
    function scheduleFivePlayers(players, rounds) {
      let sched = [];
      let restingOrder = [...players];
      for (let i=0;i<rounds;i++){
        let rest = restingOrder[0];
        let active = restingOrder.slice(1);
        let team1, team2;
        if (i % 2 === 0) {
          team1 = [active[0], active[1]];
          team2 = [active[2], active[3]];
        } else {
          team1 = [active[1], active[0]];
          team2 = [active[3], active[2]];
        }
        sched.push({ id: i+1, team1, team2, rest: [rest] });
        restingOrder.push(restingOrder.shift());
      }
      return sched;
    }

    function resetPlayerStats(playersArr) {
      let stats = {};
      playersArr.forEach(p => { stats[p] = { points:0, games:0, index:"0.00" }; });
      return stats;
    }
    function calculatePlayerStats(scheduleArr, scoresArr) {
      let stats = resetPlayerStats(players);
      scoresArr.forEach(score => {
        const match = scheduleArr.find(m => m.id === score.match_number);
        if (!match) return;
        const t1 = parseInt(score.team1_score,10)||0;
        const t2 = parseInt(score.team2_score,10)||0;
        match.team1.forEach(p => { stats[p].points += t1; stats[p].games++; });
        match.team2.forEach(p => { stats[p].points += t2; stats[p].games++; });
      });
      Object.values(stats).forEach(s => { s.index = s.games>0 ? (s.points/s.games).toFixed(2) : "0.00"; });
      return stats;
    }

    // ---------- UI RENDERERS (kept original) ----------
    function renderSchedule() {
      if (!schedule.length) {
        scheduleOutput.innerHTML = "<p>No schedule generated.</p>";
        return;
      }
      let html = `<table><thead><tr>
        <th>Match #</th>
        ${playerCount === 5 ? "<th>Resting</th>" : ""}
        <th>Team 1</th><th>Team 2</th><th>Score Team 1</th><th>Score Team 2</th>
      </tr></thead><tbody>`;
      schedule.forEach(match => {
        const restStr = playerCount === 5 ? `<td>${match.rest[0] || ''}</td>` : "";
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        const isEditable = currentGameSet && currentGameSet.editable;
        html += `<tr data-matchid="${match.id}">
          <td>${match.id}</td>
          ${restStr}
          <td>${match.team1.join(" & ")}</td>
          <td>${match.team2.join(" & ")}</td>
          <td><input class="score-input" type="number" min="0" max="99" value="${scoreEntry.team1_score ?? ''}" data-team="1" data-match="${match.id}" ${!isEditable ? 'disabled' : ''} /></td>
          <td><input class="score-input" type="number" min="0" max="99" value="${scoreEntry.team2_score ?? ''}" data-team="2" data-match="${match.id}" ${!isEditable ? 'disabled' : ''} /></td>
        </tr>`;
      });
      html += "</tbody></table>";
      scheduleOutput.innerHTML = html;

      if (currentGameSet && currentGameSet.editable) {
        document.querySelectorAll(".score-input").forEach(input => {
          input.onchange = async (e) => {
            const matchId = parseInt(e.target.dataset.match, 10);
            const teamNum = e.target.dataset.team;
            const val = e.target.value;
            await saveScore(matchId, teamNum, val);
          };
        });
      }
    }

    function renderScoreboard() {
      playerStats = calculatePlayerStats(schedule, scores);
      let html = `<table><thead><tr>
        <th>Player</th><th>Points</th><th>Games Played</th><th>Points/Game Index</th>
      </tr></thead><tbody>`;
      Object.entries(playerStats).forEach(([player, stat]) => {
        html += `<tr>
          <td>${player}</td>
          <td>${stat.points}</td>
          <td>${stat.games}</td>
          <td>${stat.index}</td>
        </tr>`;
      });
      html += "</tbody></table>";
      scoreboardDiv.innerHTML = html;
    }

    function renderMatchHistory() {
      if (!schedule.length) {
        matchListDiv.innerHTML = "<p>No matches yet.</p>";
        return;
      }
      let html = `<table><thead><tr>
        <th>Match ID</th><th>Date/Time</th><th>Team 1</th><th>Team 1 Score</th><th>Team 2</th><th>Team 2 Score</th>
        ${playerCount===5? "<th>Resting</th>":""}
      </tr></thead><tbody>`;
      schedule.forEach(match => {
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        const dt = new Date().toLocaleString();
        html += `<tr>
          <td>${match.id}</td>
          <td>${dt}</td>
          <td>${match.team1.join(" & ")}</td>
          <td>${scoreEntry.team1_score ?? ""}</td>
          <td>${match.team2.join(" & ")}</td>
          <td>${scoreEntry.team2_score ?? ""}</td>
          ${playerCount===5? `<td>${match.rest[0] || ''}</td>` : ""}
        </tr>`;
      });
      html += "</tbody></table>";
      matchListDiv.innerHTML = html;
    }

    // ---------- DB + Auth FUNCTIONS ----------
    async function signIn(email, password) {
      authMessage.textContent = '';
      const { data, error } = await sb.auth.signInWithPassword({ email, password });
      if (error) {
        authMessage.textContent = 'Login failed: ' + error.message;
        return null;
      }
      return data.user;
    }
    async function signUp(email, password) {
      authMessage.textContent = '';
      const { data, error } = await sb.auth.signUp({ email, password });
      if (error) {
        authMessage.textContent = 'Signup failed: ' + error.message;
        return null;
      }
      authMessage.textContent = 'Signup success. Check your email to confirm.';
      return data.user;
    }
    async function signOut() {
      await sb.auth.signOut();
      user = null;
      currentGameSet = null;
      gameSets = [];
      schedule = [];
      scores = [];
      showLogin();
    }

    function showLogin() {
      authContainer.style.display = 'flex';
      mainContainer.style.display = 'none';
      authMessage.textContent = '';
    }
    function showApp() {
      authContainer.style.display = 'none';
      mainContainer.style.display = 'flex';
    }

    async function loadGameSets() {
      if (!user) return;
      const { data, error } = await sb
        .from('game_sets')
        .select('*')
        .eq('user_id', user.id)
        .order('date', { ascending: false });
      if (error) {
        alert('Error loading game sets: ' + error.message);
        return;
      }
      gameSets = data;
      populateGameSetSelect();
    }

    function populateGameSetSelect() {
      gameSetSelect.innerHTML = '';
      if (gameSets.length === 0) {
        const opt = document.createElement('option');
        opt.text = 'No game sets found';
        opt.disabled = true;
        gameSetSelect.add(opt);
        currentGameSet = null;
        clearSchedule();
        return;
      }
      gameSets.forEach(gs => {
        const opt = document.createElement('option');
        opt.value = gs.id;
        opt.text = gs.date + (gs.editable ? ' (Editable)' : ' (Locked)');
        gameSetSelect.add(opt);
      });
      gameSetSelect.selectedIndex = 0;
      loadSelectedGameSet();
    }

    async function loadSelectedGameSet() {
      const gsId = gameSetSelect.value;
      if (!gsId) return;
      currentGameSet = gameSets.find(gs => gs.id == gsId);
      if (!currentGameSet) return;

      const { data, error } = await sb
        .from('games')
        .select('*')
        .eq('game_set_id', gsId)
        .order('match_number', { ascending: true });
      if (error) {
        alert('Error loading games: ' + error.message);
        return;
      }

      schedule = data.map(g => ({
        id: g.match_number,
        team1: JSON.parse(g.team1),
        team2: JSON.parse(g.team2),
        rest: JSON.parse(g.resting_players || '[]')
      }));
      scores = data.map(g => ({
        match_number: g.match_number,
        team1_score: g.team1_score,
        team2_score: g.team2_score
      }));

      playerCount = currentGameSet.player_count || 5;
      rounds = currentGameSet.rounds || schedule.length || 15;
      players = currentGameSet.player_names_json ? JSON.parse(currentGameSet.player_names_json) : [];

      playerCountSelect.value = playerCount;
      roundsInput.value = rounds;
      playerNamesInput.value = players.join(',');

      editableToggle.checked = !!currentGameSet.editable;

      renderSchedule();
      renderScoreboard();
      renderMatchHistory();
    }

    function clearSchedule() {
      schedule = [];
      scores = [];
      players = [];
      playerCount = 5;
      rounds = 15;
      playerCountSelect.value = playerCount;
      roundsInput.value = rounds;
      playerNamesInput.value = '';
      editableToggle.checked = false;
      scheduleOutput.innerHTML = '';
      scoreboardDiv.innerHTML = '';
      matchListDiv.innerHTML = '';
    }

    async function createNewGameSet() {
      if (!user) return;
      const today = formatDate(new Date());
      const exists = gameSets.find(gs => gs.date === today);
      if (exists) {
        alert("A game set for today already exists. Delete it first to create new.");
        return;
      }
      const { data, error } = await sb
        .from('game_sets')
        .insert({
          user_id: user.id,
          date: today,
          editable: true,
          player_count: 5,
          rounds: 15,
          player_names_json: JSON.stringify([])
        })
        .select()
        .single();
      if (error) {
        alert('Error creating game set: ' + error.message);
        return;
      }
      gameSets.unshift(data);
      populateGameSetSelect();
      gameSetSelect.value = data.id;
      await loadSelectedGameSet();
    }

    async function saveScheduleAndMatches() {
      if (!currentGameSet || !user) return;
      const names = playerNamesInput.value.split(',').map(s => s.trim()).filter(s => s);
      if (!validatePlayerNames(names, playerCountSelect.value)) {
        alert(`Please enter exactly ${playerCountSelect.value} player names.`);
        return;
      }
      players = names;
      playerCount = parseInt(playerCountSelect.value, 10);
      rounds = parseInt(roundsInput.value, 10);

      if (playerCount === 4) schedule = scheduleFourPlayers(players, rounds);
      else schedule = scheduleFivePlayers(players, rounds);

      const { error: updateSetErr } = await sb
        .from('game_sets')
        .update({
          player_count: playerCount,
          rounds: rounds,
          player_names_json: JSON.stringify(players),
          editable: editableToggle.checked
        })
        .eq('id', currentGameSet.id);
      if (updateSetErr) {
        alert('Error updating game set: ' + updateSetErr.message);
        return;
      }
      currentGameSet.player_count = playerCount;
      currentGameSet.rounds = rounds;
      currentGameSet.player_names_json = JSON.stringify(players);
      currentGameSet.editable = editableToggle.checked;

      const { error: delErr } = await sb
        .from('games')
        .delete()
        .eq('game_set_id', currentGameSet.id);
      if (delErr) {
        alert('Error deleting old games: ' + delErr.message);
        return;
      }

      for (let match of schedule) {
        const { error: insErr } = await sb
          .from('games')
          .insert({
            game_set_id: currentGameSet.id,
            match_number: match.id,
            team1: JSON.stringify(match.team1),
            team2: JSON.stringify(match.team2),
            resting_players: JSON.stringify(match.rest),
            team1_score: 0,
            team2_score: 0
          });
        if (insErr) {
          alert('Error inserting game: ' + insErr.message);
          return;
        }
      }
      await loadSelectedGameSet();
      alert('Schedule saved!');
    }

    async function saveScore(matchId, teamNum, val) {
      if (!currentGameSet || !currentGameSet.editable) {
        alert("This game set is locked from editing.");
        await loadSelectedGameSet(); // revert UI
        return;
      }
      const parsedVal = parseInt(val, 10);
      if (isNaN(parsedVal) || parsedVal < 0) {
        alert("Score must be a non-negative number.");
        await loadSelectedGameSet();
        return;
      }
      let scoreEntry = scores.find(s => s.match_number === matchId);
      if (!scoreEntry) { scoreEntry = { match_number: matchId, team1_score:0, team2_score:0 }; scores.push(scoreEntry); }
      if (teamNum === "1") scoreEntry.team1_score = parsedVal;
      else scoreEntry.team2_score = parsedVal;

      const { error } = await sb
        .from('games')
        .update({
          team1_score: scoreEntry.team1_score,
          team2_score: scoreEntry.team2_score
        })
        .eq('game_set_id', currentGameSet.id)
        .eq('match_number', matchId);
      if (error) {
        alert('Error updating score: ' + error.message);
        return;
      }
      renderScoreboard();
      renderMatchHistory();
    }

    function validatePlayerNames(names, count) {
      if (names.length !== parseInt(count, 10)) return false;
      for (const n of names) if (!n) return false;
      return true;
    }

    function exportCsv() {
      if (!schedule.length) { alert("Generate or select a schedule first."); return; }
      let csv = [];
      let headers = ["Match ID", "Team1 Player1", "Team1 Player2", "Team1 Score", "Team2 Player1", "Team2 Player2", "Team2 Score"];
      if (playerCount === 5) headers.push("Resting Player");
      csv.push(headers.join(","));
      schedule.forEach(match => {
        const scoreEntry = scores.find(s => s.match_number === match.id) || { team1_score: "", team2_score: "" };
        let row = [ match.id, match.team1[0], match.team1[1], scoreEntry.team1_score || "", match.team2[0], match.team2[1], scoreEntry.team2_score || "" ];
        if (playerCount === 5) row.push(match.rest[0] || "");
        csv.push(row.map(v => `"${v}"`).join(","));
      });
      const csvString = csv.join("\n");
      const blob = new Blob([csvString], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `padel_game_set_${currentGameSet ? currentGameSet.date : 'export'}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ---------- EVENT HANDLERS ----------
    loginBtn.onclick = async () => {
      user = await signIn(emailInput.value.trim(), passwordInput.value.trim());
      if (user) {
        authMessage.textContent = '';
        await afterLogin();
      }
    };
    signupBtn.onclick = async () => {
      const newUser = await signUp(emailInput.value.trim(), passwordInput.value.trim());
      if (newUser) authMessage.textContent = 'Signup success. Check email.';
    };
    newSetBtn.onclick = async () => await createNewGameSet();
    gameSetSelect.onchange = async () => await loadSelectedGameSet();
    generateBtn.onclick = async () => await saveScheduleAndMatches();
    editableToggle.onchange = async () => {
      if (!currentGameSet) return;
      const { error } = await sb.from('game_sets').update({ editable: editableToggle.checked }).eq('id', currentGameSet.id);
      if (error) {
        alert('Error updating editable flag: ' + error.message);
        editableToggle.checked = !editableToggle.checked;
      } else {
        currentGameSet.editable = editableToggle.checked;
        renderSchedule();
      }
    };
    exportCsvBtn.onclick = exportCsv;

    async function afterLogin() {
      const { data: { user: gotUser } } = await sb.auth.getUser();
      user = gotUser;
      if (!user) { showLogin(); return; }
      showApp();
      await loadGameSets();
    }

    // ---------- INIT: check session ----------
    try {
      const { data: { session } } = await sb.auth.getSession();
      if (session && session.user) {
        user = session.user;
        showApp();
        await loadGameSets();
      } else {
        showLogin();
      }
    } catch (e) {
      console.error('Init session error', e);
      showLogin();
    }

  })();
</script>

</body>
</html>
