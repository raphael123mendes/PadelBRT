<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Padel Manager - Scheduler & Scoring</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600&display=swap');
    body {
      margin: 0; padding: 20px;
      background: linear-gradient(135deg, #42291a 0%, #f5d68f 100%);
      font-family: 'Rajdhani', sans-serif;
      color: #2c1b0f;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }
    h1 {
      margin-bottom: 5px;
      color: #f2e4c9;
      text-shadow: 0 0 8px #8a5a21;
    }
    label, select, input, button {
      font-size: 1.1rem;
      margin: 5px 0;
      border-radius: 6px;
    }
    select, input[type=text], input[type=number] {
      padding: 8px 10px;
      border: none;
      width: 280px;
      box-sizing: border-box;
      outline: none;
      border: 2px solid #c3a66d;
      background: #fff9e1;
      color: #4d3b1b;
      transition: border-color 0.3s ease;
    }
    select:focus, input[type=text]:focus, input[type=number]:focus {
      border-color: #8a5a21;
    }
    button {
      background: #8a5a21;
      color: #f2e4c9;
      border: none;
      padding: 12px 22px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(138, 90, 33, 0.6);
      transition: background-color 0.3s ease;
      user-select: none;
    }
    button:hover {
      background: #6b4413;
    }
    table {
      margin-top: 25px;
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
      background: #f5d68f;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      user-select: text;
    }
    th, td {
      padding: 10px 12px;
      text-align: center;
      border-bottom: 1px solid #c3a66d;
      font-weight: 600;
      color: #4d3b1b;
    }
    th {
      background: #8a5a21;
      color: #f2e4c9;
      user-select: none;
    }
    input.score-input {
      width: 48px;
      padding: 6px 4px;
      font-size: 1rem;
      text-align: center;
      border: 2px solid #c3a66d;
      border-radius: 6px;
      background: #fff9e1;
      color: #4d3b1b;
    }
    .container {
      width: 100%;
      max-width: 960px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #matchList {
      max-height: 300px;
      overflow-y: auto;
    }
    #exportCsvBtn {
      margin-top: 15px;
      background: #6b4413;
    }
    #persistenceToggle {
      margin-left: 8px;
      vertical-align: middle;
      transform: scale(1.2);
      cursor: pointer;
    }
    #scoreboard {
      margin-top: 25px;
      max-width: 600px;
      width: 100%;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgb(69 44 16 / 0.7);
      background: #f5d68f;
      padding: 10px 0;
    }
    #scoreboard table {
      width: 100%;
      border-collapse: collapse;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Padel Manager</h1>

  <label for="playerCount">Select Players (no mid-session switch):</label>
  <select id="playerCount">
    <option value="4">4 Players</option>
    <option value="5" selected>5 Players</option>
  </select>

  <label for="playerNames">Enter Player Names (comma separated):</label>
  <input id="playerNames" type="text" placeholder="Alice,Bob,Charlie,David,Eva" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

  <label for="rounds">Number of rounds (games):</label>
  <input id="rounds" type="number" min="1" value="15" />

  <button id="generateBtn">Generate Schedule</button>

  <label><input type="checkbox" id="persistenceToggle" checked /> Persist scores between reloads</label>

  <div id="scheduleOutput"></div>

  <div id="scoreboard"></div>

  <h2>Match History (editable scores)</h2>
  <div id="matchList"></div>

  <button id="exportCsvBtn">Export Matches CSV</button>
</div>

<script>
(() => {
  const playerCountSelect = document.getElementById("playerCount");
  const playerNamesInput = document.getElementById("playerNames");
  const roundsInput = document.getElementById("rounds");
  const generateBtn = document.getElementById("generateBtn");
  const scheduleOutput = document.getElementById("scheduleOutput");
  const scoreboardDiv = document.getElementById("scoreboard");
  const matchListDiv = document.getElementById("matchList");
  const exportCsvBtn = document.getElementById("exportCsvBtn");
  const persistenceToggle = document.getElementById("persistenceToggle");

  // State
  let players = [];
  let playerCount = 5;
  let rounds = 15;
  let schedule = [];
  let scores = []; // Array of { matchId, team1Score, team2Score }
  let playerStats = {}; // playerName -> { points, games, index }

  // Save/load persistence keys
  const STORAGE_KEY = "padel_manager_data";

  // --- Scheduler for 4 players ---
  function scheduleFourPlayers(players, rounds) {
    // Basic doubles combos rotating partners/opponents:
    // 4 players total: A,B,C,D
    // Games cycle through 2 distinct doubles teams:
    // Round 1: A&B vs C&D
    // Round 2: A&C vs B&D
    // Round 3: A&D vs B&C
    // Repeat if rounds > 3

    const combos = [
      [[players[0], players[1]], [players[2], players[3]]],
      [[players[0], players[2]], [players[1], players[3]]],
      [[players[0], players[3]], [players[1], players[2]]]
    ];

    let schedule = [];
    for(let i=0; i < rounds; i++) {
      const c = combos[i % combos.length];
      schedule.push({
        id: i+1,
        team1: c[0],
        team2: c[1],
        rest: []
      });
    }
    return schedule;
  }

  // --- Scheduler for 5 players ---
  function scheduleFivePlayers(players, rounds) {
    // 5 players, doubles games, 1 rests each round
    // Rules: rotate resting player each round (no consecutive rests)
    // Rotate players so partners/opponents vary as much as possible
    // This algorithm fixes rest rotation and cycles teams.

    let schedule = [];
    // Rotation order for resting player
    let restingOrder = [...players];

    // The 4 active players per round will be formed as:
    // team1: restingOrder[1], restingOrder[2]
    // team2: restingOrder[3], restingOrder[4]

    // For variety, alternate team1 and team2 order every round to reduce repeat partners
    for(let i=0; i < rounds; i++) {
      let rest = restingOrder[0];
      let active = restingOrder.slice(1);

      // Alternate partner order every round for diversity
      let team1, team2;
      if (i % 2 === 0) {
        team1 = [active[0], active[1]];
        team2 = [active[2], active[3]];
      } else {
        team1 = [active[1], active[0]];
        team2 = [active[3], active[2]];
      }

      schedule.push({
        id: i+1,
        team1,
        team2,
        rest: [rest]
      });

      // Rotate resting order so no consecutive rests for same player
      restingOrder.push(restingOrder.shift());
    }
    return schedule;
  }

  // Validate player names count matches playerCount
  function validatePlayerNames(names, count) {
    if (names.length !== count) return false;
    for (const n of names) if (!n) return false;
    return true;
  }

  // Initialize empty player stats
  function resetPlayerStats(players) {
    let stats = {};
    players.forEach(p => {
      stats[p] = { points: 0, games: 0, index: 0 };
    });
    return stats;
  }

  // Calculate player stats from scores and schedule
  function calculatePlayerStats(schedule, scores) {
    let stats = resetPlayerStats(players);
    scores.forEach(score => {
      let match = schedule.find(m => m.id === score.matchId);
      if (!match) return;
      const t1score = parseInt(score.team1Score, 10) || 0;
      const t2score = parseInt(score.team2Score, 10) || 0;
      const winner = t1score > t2score ? "team1" : (t2score > t1score ? "team2" : null);

      // Assign points per player based on team result
      if (winner === "team1") {
        match.team1.forEach(p => {
          stats[p].points += t1score;
          stats[p].games++;
        });
        match.team2.forEach(p => {
          stats[p].points += t2score;
          stats[p].games++;
        });
      } else if (winner === "team2") {
        match.team1.forEach(p => {
          stats[p].points += t1score;
          stats[p].games++;
        });
        match.team2.forEach(p => {
          stats[p].points += t2score;
          stats[p].games++;
        });
      } else {
        // Tie? Assign points but games played still count
        match.team1.forEach(p => {
          stats[p].points += t1score;
          stats[p].games++;
        });
        match.team2.forEach(p => {
          stats[p].points += t2score;
          stats[p].games++;
        });
      }
    });

    // Calculate index = points / games played
    Object.values(stats).forEach(s => {
      s.index = s.games > 0 ? (s.points / s.games).toFixed(2) : "0.00";
    });
    return stats;
  }

  // Render schedule + inputs for scores
  function renderSchedule(schedule, playerCount) {
    if (!schedule.length) {
      scheduleOutput.innerHTML = "<p>No schedule generated yet.</p>";
      return;
    }

    let html = `<table><thead><tr>
      <th>Match #</th>
      ${playerCount === 5 ? "<th>Resting</th>" : ""}
      <th>Team 1</th><th>Team 2</th><th>Score Team 1</th><th>Score Team 2</th>
    </tr></thead><tbody>`;

    schedule.forEach(match => {
      const restStr = playerCount === 5 ? `<td>${match.rest[0]}</td>` : "";
      const scoreObj = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };

      html += `<tr data-matchid="${match.id}">
        <td>${match.id}</td>
        ${restStr}
        <td>${match.team1.join(" & ")}</td>
        <td>${match.team2.join(" & ")}</td>
        <td><input class="score-input" type="number" min="0" max="3" pattern="[0-3]" inputmode="numeric" maxlength="1" value="${scoreObj.team1Score}" data-team="1" data-match="${match.id}" /></td>
        <td><input class="score-input" type="number" min="0" max="3" pattern="[0-3]" inputmode="numeric" maxlength="1" value="${scoreObj.team2Score}" data-team="2" data-match="${match.id}" /></td>
      </tr>`;
    });
    html += "</tbody></table>";
    scheduleOutput.innerHTML = html;

    // Attach event listeners for score inputs
    document.querySelectorAll(".score-input").forEach(input => {
      input.addEventListener("input", e => {
        const matchId = parseInt(e.target.dataset.match, 10);
        const teamNum = e.target.dataset.team;
        let scoreEntry = scores.find(s => s.matchId === matchId);
        if (!scoreEntry) {
          scoreEntry = { matchId, team1Score: "", team2Score: "" };
          scores.push(scoreEntry);
        }
        if (teamNum === "1") scoreEntry.team1Score = e.target.value;
        else scoreEntry.team2Score = e.target.value;
        updateAfterScoreChange();
      });
    });
  }

  // Render scoreboard with player stats
  function renderScoreboard(stats) {
    let html = `<table><thead><tr>
      <th>Player</th><th>Points</th><th>Games Played</th><th>Points/Game Index</th>
    </tr></thead><tbody>`;

    Object.entries(stats).forEach(([player, stat]) => {
      html += `<tr>
        <td>${player}</td>
        <td>${stat.points}</td>
        <td>${stat.games}</td>
        <td>${stat.index}</td>
      </tr>`;
    });
    html += "</tbody></table>";
    scoreboardDiv.innerHTML = html;
  }

  // Render match history with all matches & scores for CSV export
  function renderMatchHistory(schedule) {
    if (!schedule.length) {
      matchListDiv.innerHTML = "<p>No matches yet.</p>";
      return;
    }

    let html = `<table><thead><tr>
      <th>Match ID</th>
      <th>Date/Time</th>
      <th>Team 1</th><th>Team 1 Score</th>
      <th>Team 2</th><th>Team 2 Score</th>
      ${playerCount === 5 ? "<th>Resting</th>" : ""}
    </tr></thead><tbody>`;

    schedule.forEach(match => {
      const scoreEntry = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };
      const dt = new Date().toLocaleString();

      html += `<tr>
        <td>${match.id}</td>
        <td>${dt}</td>
        <td>${match.team1.join(" & ")}</td>
        <td>${scoreEntry.team1Score || ""}</td>
        <td>${match.team2.join(" & ")}</td>
        <td>${scoreEntry.team2Score || ""}</td>
        ${playerCount === 5 ? `<td>${match.rest[0]}</td>` : ""}
      </tr>`;
    });

    html += "</tbody></table>";
    matchListDiv.innerHTML = html;
  }

  // Update everything after scores change
  function updateAfterScoreChange() {
    playerStats = calculatePlayerStats(schedule, scores);
    renderScoreboard(playerStats);
    renderMatchHistory(schedule);
    if (persistenceToggle.checked) saveData();
  }

  // Save data to localStorage
  function saveData() {
    try {
      const data = {
        players,
        playerCount,
        rounds,
        schedule,
        scores
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch (e) {
      console.warn("Failed to save data:", e);
    }
  }

  // Load data from localStorage
  function loadData() {
    try {
      const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
      if (!data) return false;
      players = data.players || [];
      playerCount = data.playerCount || 5;
      rounds = data.rounds || 15;
      schedule = data.schedule || [];
      scores = data.scores || [];
      // Restore UI values
      playerCountSelect.value = playerCount;
      playerNamesInput.value = players.join(",");
      roundsInput.value = rounds;
      renderSchedule(schedule, playerCount);
      updateAfterScoreChange();
      return true;
    } catch(e) {
      console.warn("Failed to load data:", e);
      return false;
    }
  }

  // Export CSV
  function exportCsv() {
    if (!schedule.length) {
      alert("Generate a schedule first.");
      return;
    }
    let csv = [];
    // Header row
    let headers = ["Match ID", "Date/Time", "Team1 Player1", "Team1 Player2", "Team1 Score", "Team2 Player1", "Team2 Player2", "Team2 Score"];
    if (playerCount === 5) headers.push("Resting Player");
    csv.push(headers.join(","));

    schedule.forEach(match => {
      const scoreEntry = scores.find(s => s.matchId === match.id) || { team1Score: "", team2Score: "" };
      const dt = new Date().toLocaleString();
      let row = [
        match.id,
        dt,
        match.team1[0],
        match.team1[1],
        scoreEntry.team1Score || "",
        match.team2[0],
        match.team2[1],
        scoreEntry.team2Score || ""
      ];
      if (playerCount === 5) row.push(match.rest[0]);
      csv.push(row.map(v => `"${v}"`).join(","));
    });

    const csvContent = "data:text/csv;charset=utf-8," + csv.join("\n");
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `padel_matches_${new Date().toISOString().slice(0,10)}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // On generate button click
  generateBtn.addEventListener("click", () => {
    playerCount = parseInt(playerCountSelect.value, 10);
    players = playerNamesInput.value.split(",").map(p => p.trim()).filter(p => p.length > 0);
    rounds = parseInt(roundsInput.value, 10);

    if (!validatePlayerNames(players, playerCount)) {
      alert(`Please enter exactly ${playerCount} player names.`);
      return;
    }

    if (playerCount === 4) {
      schedule = scheduleFourPlayers(players, rounds);
    } else if (playerCount === 5) {
      schedule = scheduleFivePlayers(players, rounds);
    }

    scores = []; // reset scores on new schedule
    renderSchedule(schedule, playerCount);
    playerStats = resetPlayerStats(players);
    renderScoreboard(playerStats);
    renderMatchHistory(schedule);

    if (persistenceToggle.checked) saveData();
  });

  exportCsvBtn.addEventListener("click", exportCsv);

  persistenceToggle.addEventListener("change", e => {
    if (!e.target.checked) localStorage.removeItem(STORAGE_KEY);
  });

  // Load on start if persistence enabled
  if (persistenceToggle.checked) loadData();

})();
</script>

</body>
</html>
